{
  "$schema" : "http://json-schema.org/draft-07/schema#",
  "definitions" : {
    "composable_index_template" : {
      "type" : "object",
      "properties" : {
        "index_patterns" : {
          "description" : "Array of wildcard (`*`) expressions used to match the names of data streams and indices during creation.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Indices"
          } ]
        },
        "composed_of" : {
          "description" : "Specific to composable index templates.\nAn ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.",
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/_types.Name"
          }
        },
        "template" : {
          "description" : "Specific to composable index templates.\nTemplate to be applied.\nIt may optionally include an `aliases`, `mappings`, or `settings` configuration.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices.put_index_template.IndexTemplateMapping"
          } ]
        },
        "data_stream" : {
          "description" : "Specific to composable index templates.\nIf this object is included, the template is used to create data streams and their backing indices.\nSupports an empty object.\nData streams require a matching index template with a `data_stream` object.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.DataStreamVisibility"
          } ]
        },
        "priority" : {
          "description" : "Specific to composable index templates.\nPriority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.",
          "type" : "number"
        },
        "version" : {
          "description" : "Version number used to manage index templates externally.\nThis number is not automatically generated by Elasticsearch.\nExternal systems can use these version numbers to simplify template management.\nTo unset a version, replace the template without specifying one.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionNumber"
          } ]
        },
        "_meta" : {
          "description" : "Specific to composable index templates.\nOptional user metadata about the index template.\nIt may have any contents.\nIt is not automatically generated or used by Elasticsearch.\nThis user-defined object is stored in the cluster state, so keeping it short is preferable\nTo unset the metadata, replace the template without specifying it.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Metadata"
          } ]
        },
        "allow_auto_create" : {
          "description" : "Specific to composable index templates.\nThis setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that template even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false`, then indices or data streams matching the template must always be explicitly created, and may never be automatically created.",
          "type" : "boolean"
        },
        "ignore_missing_component_templates" : {
          "description" : "Specific to composable index templates.\nThe configuration option ignore_missing_component_templates can be used when an index template\nreferences a component template that might not exist",
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        },
        "deprecated" : {
          "description" : "Specific to composable index templates.\nMarks this index template as deprecated. When creating or updating a non-deprecated index template\nthat uses deprecated components, Elasticsearch will emit a deprecation warning.",
          "type" : "boolean"
        }
      },
      "required" : [ "index_patterns" ]
    },
    "_types.VersionNumber" : {
      "type" : "number",
      "description" : "A number representing a version"
    },
    "indices._types.DataStreamVisibility" : {
      "type" : "object",
      "properties" : {
        "hidden" : {
          "type" : "boolean"
        },
        "allow_custom_routing" : {
          "type" : "boolean",
          "description" : "Since Elasticsearch 8.0.0",
          "default" : false
        }
      }
    },
    "indices.put_index_template.IndexTemplateMapping" : {
      "type" : "object",
      "properties" : {
        "aliases" : {
          "description" : "Aliases to add.\nIf the index template includes a `data_stream` object, these are data stream aliases.\nOtherwise, these are index aliases.\nData stream aliases ignore the `index_routing`, `routing`, and `search_routing` options.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/indices._types.Alias"
          },
          "defaultSnippets" : [ {
            "label" : "add new alias",
            "body" : {
              "${1:alias1}" : { }
            }
          } ]
        },
        "mappings" : {
          "description" : "Mapping for fields in the index.\nIf specified, this mapping can include field names, field data types, and mapping parameters.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.TypeMapping"
          } ]
        },
        "settings" : {
          "description" : "Configuration options for the index.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettings"
          } ]
        },
        "lifecycle" : {
          "x-state" : "Generally available; Added in 8.11.0",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.DataStreamLifecycle"
          } ],
          "description" : "Since Elasticsearch 8.11.0"
        },
        "data_stream_options" : {
          "x-state" : "Generally available; Added in 8.19.0",
          "oneOf" : [ {
            "$ref" : "#/definitions/indices._types.DataStreamOptionsTemplate"
          }, {
            "nullable" : true,
            "type" : "string"
          } ],
          "description" : "Since Elasticsearch 8.19.0"
        }
      }
    },
    "_types.Indices" : {
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.IndexName"
      }, {
        "type" : "array",
        "items" : {
          "$ref" : "#/definitions/_types.IndexName"
        }
      } ],
      "defaultSnippets" : [ {
        "label" : "define index pattern list",
        "body" : [ "${1:logstash-*}" ]
      } ]
    },
    "_types.Metadata" : {
      "type" : "object",
      "additionalProperties" : {
        "type" : "object"
      }
    },
    "_types.Name" : {
      "type" : "string"
    },
    "indices._types.Alias" : {
      "type" : "object",
      "properties" : {
        "filter" : {
          "description" : "Query used to limit documents the alias can access.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
          } ]
        },
        "index_routing" : {
          "description" : "Value used to route indexing operations to a specific shard.\nIf specified, this overwrites the `routing` value for indexing operations.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Routing"
          } ]
        },
        "is_hidden" : {
          "description" : "Since Elasticsearch 7.12.0\nIf `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.",
          "default" : false,
          "type" : "boolean"
        },
        "is_write_index" : {
          "description" : "If `true`, the index is the write index for the alias.",
          "default" : false,
          "type" : "boolean"
        },
        "routing" : {
          "description" : "Value used to route indexing and search operations to a specific shard.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Routing"
          } ]
        },
        "search_routing" : {
          "description" : "Value used to route search operations to a specific shard.\nIf specified, this overwrites the `routing` value for search operations.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Routing"
          } ]
        }
      }
    },
    "_types.mapping.TypeMapping" : {
      "type" : "object",
      "properties" : {
        "all_field" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.AllField"
          } ]
        },
        "date_detection" : {
          "type" : "boolean",
          "default" : true
        },
        "dynamic" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.DynamicMapping"
          } ],
          "default" : "true"
        },
        "dynamic_date_formats" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "examples" : [ "strict_date_time", "strict_date_optional_time", "strict_date", "epoch_millis", "epoch_second", "yyyy-MM-dd" ]
          },
          "default" : [ "strict_date_optional_time", "yyyy/MM/dd HH:mm:ss Z||yyyy/MM/dd Z" ]
        },
        "dynamic_templates" : {
          "type" : "array",
          "items" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/definitions/_types.mapping.DynamicTemplate"
            },
            "minProperties" : 1,
            "maxProperties" : 1
          },
          "defaultSnippets" : [ {
            "label" : "add new dynamic template",
            "body" : [ {
              "${1:dynamic_template1}" : { }
            } ]
          } ]
        },
        "_field_names" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.FieldNamesField"
          } ]
        },
        "index_field" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.IndexField"
          } ]
        },
        "_meta" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Metadata"
          } ]
        },
        "numeric_detection" : {
          "type" : "boolean",
          "default" : false
        },
        "properties" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.mapping.Property"
          },
          "defaultSnippets" : [ {
            "label" : "add new property",
            "body" : {
              "${1:property1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "_routing" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.RoutingField"
          } ]
        },
        "_size" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.SizeField"
          } ]
        },
        "_source" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.SourceField"
          } ]
        },
        "runtime" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.mapping.RuntimeField"
          },
          "description" : "Since Elasticsearch 7.11.0",
          "defaultSnippets" : [ {
            "label" : "add new runtime field",
            "body" : {
              "${1:runtime_field1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "enabled" : {
          "type" : "boolean"
        },
        "subobjects" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.Subobjects"
          } ]
        },
        "_data_stream_timestamp" : {
          "x-state" : "Generally available; Added in 7.16.0",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.DataStreamTimestamp"
          } ],
          "description" : "Since Elasticsearch 7.16.0"
        }
      }
    },
    "indices._types.DataStreamOptionsTemplate" : {
      "description" : "Data stream options template contains the same information as DataStreamOptions but allows them to be set explicitly to null.",
      "type" : "object",
      "properties" : {
        "failure_store" : {
          "oneOf" : [ {
            "$ref" : "#/definitions/indices._types.DataStreamFailureStoreTemplate"
          }, {
            "nullable" : true,
            "type" : "string"
          } ]
        }
      }
    },
    "indices._types.IndexSettings" : {
      "type" : "object",
      "properties" : {
        "index" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettings"
          } ]
        },
        "mode" : {
          "type" : "string",
          "description" : "Since Elasticsearch 8.14.0",
          "default" : "standard",
          "examples" : [ "time_series", "logsdb" ]
        },
        "routing_path" : {
          "oneOf" : [ {
            "type" : "string"
          }, {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          } ]
        },
        "soft_deletes" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SoftDeletes"
          } ]
        },
        "sort" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSegmentSort"
          } ]
        },
        "number_of_shards" : {
          "default" : "1",
          "x-state" : "Generally available",
          "oneOf" : [ {
            "type" : "number"
          }, {
            "type" : "string"
          } ]
        },
        "number_of_replicas" : {
          "default" : "0",
          "x-state" : "Generally available",
          "oneOf" : [ {
            "type" : "number"
          }, {
            "type" : "string"
          } ]
        },
        "number_of_routing_shards" : {
          "type" : "number",
          "default" : "1"
        },
        "check_on_startup" : {
          "default" : "false",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexCheckOnStartup"
          } ]
        },
        "codec" : {
          "default" : "LZ4",
          "type" : "string"
        },
        "routing_partition_size" : {
          "default" : "1",
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
          } ]
        },
        "load_fixed_bitset_filters_eagerly" : {
          "default" : true,
          "type" : "boolean"
        },
        "hidden" : {
          "default" : "false",
          "oneOf" : [ {
            "type" : "boolean"
          }, {
            "type" : "string"
          } ],
          "description" : "Since Elasticsearch 7.9.0"
        },
        "auto_expand_replicas" : {
          "default" : "false",
          "oneOf" : [ {
            "type" : "string"
          }, {
            "$ref" : "#/definitions/_spec_utils.NullValue"
          } ],
          "examples" : [ "0-1" ]
        },
        "merge" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.Merge"
          } ]
        },
        "search" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SettingsSearch"
          } ]
        },
        "refresh_interval" : {
          "default" : "1s",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        },
        "max_result_window" : {
          "default" : 10000.0,
          "type" : "number"
        },
        "max_inner_result_window" : {
          "default" : 100.0,
          "type" : "number"
        },
        "max_rescore_window" : {
          "default" : 10000.0,
          "type" : "number"
        },
        "max_docvalue_fields_search" : {
          "default" : 100.0,
          "type" : "number"
        },
        "max_script_fields" : {
          "default" : 32.0,
          "type" : "number"
        },
        "max_ngram_diff" : {
          "default" : 1.0,
          "type" : "number"
        },
        "max_shingle_diff" : {
          "default" : 3.0,
          "type" : "number"
        },
        "blocks" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettingBlocks"
          } ]
        },
        "max_refresh_listeners" : {
          "type" : "number",
          "default" : "1000"
        },
        "analyze" : {
          "description" : "Settings to define analyzers, tokenizers, token filters and character filters.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SettingsAnalyze"
          } ]
        },
        "highlight" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SettingsHighlight"
          } ]
        },
        "max_terms_count" : {
          "default" : 65536.0,
          "type" : "number"
        },
        "max_regex_length" : {
          "default" : 1000.0,
          "type" : "number"
        },
        "routing" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRouting"
          } ]
        },
        "gc_deletes" : {
          "default" : "60s",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        },
        "default_pipeline" : {
          "default" : "_none",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.PipelineName"
          } ]
        },
        "final_pipeline" : {
          "default" : "_none",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.PipelineName"
          } ],
          "description" : "Since Elasticsearch 7.5.0"
        },
        "lifecycle" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettingsLifecycle"
          } ]
        },
        "provided_name" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Name"
          } ]
        },
        "creation_date" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.StringifiedEpochTimeUnitMillis"
          } ]
        },
        "creation_date_string" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DateTime"
          } ]
        },
        "uuid" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Uuid"
          } ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexVersioning"
          } ]
        },
        "verified_before_close" : {
          "oneOf" : [ {
            "type" : "boolean"
          }, {
            "type" : "string"
          } ],
          "default" : "false"
        },
        "format" : {
          "oneOf" : [ {
            "type" : "string"
          }, {
            "type" : "number"
          } ],
          "default" : "0"
        },
        "max_slices_per_scroll" : {
          "type" : "number",
          "default" : "1024"
        },
        "translog" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.Translog"
          } ]
        },
        "query_string" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SettingsQueryString"
          } ]
        },
        "priority" : {
          "oneOf" : [ {
            "type" : "number"
          }, {
            "type" : "string"
          } ],
          "default" : "1"
        },
        "top_metrics_max_size" : {
          "type" : "number",
          "default" : 10,
          "description" : "Since Elasticsearch 7.9.0"
        },
        "analysis" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettingsAnalysis"
          } ]
        },
        "settings" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettings"
          } ]
        },
        "time_series" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettingsTimeSeries"
          } ]
        },
        "queries" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.Queries"
          } ]
        },
        "similarity" : {
          "description" : "Configure custom similarity settings to customize how search results are scored.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/indices._types.SettingsSimilarity"
          }
        },
        "mapping" : {
          "description" : "Enable or disable dynamic mapping for an index.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettings"
          } ]
        },
        "indexing.slowlog" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexingSlowlogSettings"
          } ]
        },
        "indexing_pressure" : {
          "description" : "Configure indexing back pressure limits.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexingPressure"
          } ]
        },
        "store" : {
          "description" : "The store module allows you to control how index data is stored and accessed on disk.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.Storage"
          } ]
        },
        "allocation" : {
          "properties" : {
            "max_retries" : {
              "type" : "integer",
              "default" : 5
            }
          }
        },
        "compound_format" : {
          "type" : "string",
          "default" : "0.1"
        },
        "downsample" : {
          "type" : "object",
          "description" : "Since Elasticsearch 8.5.0",
          "properties" : {
            "interval" : {
              "type" : "string",
              "default" : ""
            },
            "status" : {
              "type" : "string",
              "default" : "unknown"
            }
          }
        },
        "fielddata" : {
          "type" : "object",
          "properties" : {
            "cache" : {
              "type" : "string",
              "default" : "node"
            }
          }
        },
        "flush_after_merge" : {
          "type" : "string",
          "default" : "512mb"
        },
        "look_ahead_time" : {
          "$ref" : "#/definitions/_types.Duration",
          "default" : "30m"
        },
        "look_back_time" : {
          "$ref" : "#/definitions/_types.Duration",
          "default" : "2h"
        },
        "query" : {
          "type" : "object",
          "properties" : {
            "default_field" : {
              "type" : "array",
              "items" : {
                "type" : "string",
                "examples" : [ "*" ]
              }
            },
            "parse" : {
              "type" : "object",
              "properties" : {
                "allow_unmapped_fields" : {
                  "type" : "boolean",
                  "default" : true
                }
              }
            }
          }
        },
        "requests" : {
          "type" : "object",
          "properties" : {
            "cache" : {
              "type" : "object",
              "properties" : {
                "enable" : {
                  "oneOf" : [ {
                    "type" : "boolean"
                  }, {
                    "type" : "string",
                    "enum" : [ "true", "false" ]
                  } ],
                  "default" : true
                }
              }
            }
          }
        }
      }
    },
    "indices._types.DataStreamLifecycle" : {
      "description" : "Data stream lifecycle denotes that a data stream is managed by the data stream lifecycle and contains the configuration.",
      "type" : "object",
      "properties" : {
        "data_retention" : {
          "description" : "If defined, every document added to this data stream will be stored at least for this time frame.\nAny time after this duration the document could be deleted.\nWhen empty, every document in this data stream will be stored indefinitely.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        },
        "downsampling" : {
          "description" : "The list of downsampling rounds to execute as part of this downsampling configuration",
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/indices._types.DownsamplingRound"
          }
        },
        "enabled" : {
          "description" : "If defined, it turns data stream lifecycle on/off (`true`/`false`) for this data stream. A data stream lifecycle\nthat's disabled (enabled: `false`) will have no effect on the data stream.",
          "default" : true,
          "type" : "boolean"
        }
      }
    },
    "_types.IndexName" : {
      "type" : "string"
    },
    "indices._types.Merge" : {
      "type" : "object",
      "properties" : {
        "scheduler" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MergeScheduler"
          } ]
        }
      }
    },
    "indices._types.SettingsHighlight" : {
      "type" : "object",
      "properties" : {
        "max_analyzed_offset" : {
          "default" : 1000000.0,
          "type" : "number"
        }
      }
    },
    "_types.mapping.DynamicMapping" : {
      "type" : "string",
      "enum" : [ "strict", "runtime", "true", "false" ]
    },
    "_types.mapping.RuntimeField" : {
      "type" : "object",
      "properties" : {
        "fields" : {
          "description" : "For type `composite`",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.mapping.CompositeSubField"
          }
        },
        "fetch_fields" : {
          "description" : "For type `lookup`",
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/_types.mapping.RuntimeFieldFetchFields"
          }
        },
        "format" : {
          "description" : "A custom format for `date` type runtime fields.",
          "type" : "string"
        },
        "input_field" : {
          "description" : "For type `lookup`",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "target_field" : {
          "description" : "For type `lookup`",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "target_index" : {
          "description" : "For type `lookup`\nFor type `lookup`",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.IndexName"
          } ]
        },
        "script" : {
          "description" : "Painless script executed at query time.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Script"
          } ]
        },
        "type" : {
          "description" : "Field type, which can be: `boolean`, `composite`, `date`, `double`, `geo_point`, `ip`,`keyword`, `long`, or `lookup`.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.RuntimeFieldType"
          } ]
        }
      },
      "required" : [ "type" ],
      "description" : "Since Elasticsearch 7.11.0",
      "defaultSnippets" : [ {
        "label" : "add new runtime property",
        "body" : {
          "type" : "$1"
        }
      } ]
    },
    "indices._types.IndexSettingBlocks" : {
      "type" : "object",
      "properties" : {
        "read_only" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
          } ],
          "default" : false
        },
        "read_only_allow_delete" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
          } ],
          "default" : false
        },
        "read" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
          } ],
          "default" : false
        },
        "write" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
          } ],
          "default" : false
        },
        "metadata" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
          } ],
          "default" : false
        }
      }
    },
    "indices._types.Translog" : {
      "type" : "object",
      "properties" : {
        "sync_interval" : {
          "description" : "How often the translog is fsynced to disk and committed, regardless of write operations.\nValues less than 100ms are not allowed.",
          "default" : "5s",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        },
        "durability" : {
          "description" : "Whether or not to `fsync` and commit the translog after every index, delete, update, or bulk request.",
          "default" : "string",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.TranslogDurability"
          } ]
        },
        "flush_threshold_size" : {
          "description" : "The translog stores all operations that are not yet safely persisted in Lucene (i.e., are not\npart of a Lucene commit point). Although these operations are available for reads, they will need\nto be replayed if the shard was stopped and had to be recovered. This setting controls the\nmaximum total size of these operations, to prevent recoveries from taking too long. Once the\nmaximum size has been reached a flush will happen, generating a new Lucene commit point.",
          "default" : "512mb",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.ByteSize"
          } ]
        },
        "retention" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.TranslogRetention"
          } ]
        }
      }
    },
    "indices._types.IndexSettingsTimeSeries" : {
      "type" : "object",
      "properties" : {
        "end_time" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DateTime"
          } ]
        },
        "start_time" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DateTime"
          } ]
        }
      }
    },
    "indices._types.IndexSettingsLifecycle" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "description" : "The name of the policy to use to manage the index. For information about how Elasticsearch applies policy changes, see Policy updates.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Name"
          } ]
        },
        "indexing_complete" : {
          "description" : "Indicates whether or not the index has been rolled over. Automatically set to true when ILM completes the rollover action.\nYou can explicitly set it to skip rollover.",
          "default" : "false",
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
          } ]
        },
        "origination_date" : {
          "description" : "If specified, this is the timestamp used to calculate the index age for its phase transitions. Use this setting\nif you create a new index that contains old data and want to use the original creation date to calculate the index\nage. Specified as a Unix epoch value in milliseconds.",
          "default" : 0.0,
          "type" : "number"
        },
        "parse_origination_date" : {
          "description" : "Since Elasticsearch 7.5.0\nSet to true to parse the origination date from the index name. This origination date is used to calculate the index age\nfor its phase transitions. The index name must match the pattern ^.*-{date_format}-\\\\d+, where the date_format is\nyyyy.MM.dd and the trailing digits are optional. An index that was rolled over would normally match the full format,\nfor example logs-2016.10.31-000002). If the index name doesnâ€™t match the pattern, index creation fails.",
          "type" : "boolean",
          "default" : false
        },
        "step" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexSettingsLifecycleStep"
          } ]
        },
        "rollover_alias" : {
          "description" : "The index alias to update when the index rolls over. Specify when using a policy that contains a rollover action.\nWhen the index rolls over, the alias is updated to reflect that the index is no longer the write index. For more\ninformation about rolling indices, see Rollover.",
          "default" : "",
          "type" : "string"
        },
        "prefer_ilm" : {
          "description" : "Since Elasticsearch 8.8.0\nPreference for the system that manages a data stream backing index (preferring ILM when both ILM and DLM are\napplicable for an index).",
          "default" : "true",
          "oneOf" : [ {
            "type" : "boolean"
          }, {
            "type" : "string"
          } ]
        }
      }
    },
    "_types.mapping.SourceField" : {
      "type" : "object",
      "properties" : {
        "compress" : {
          "type" : "boolean"
        },
        "compress_threshold" : {
          "type" : "string"
        },
        "enabled" : {
          "type" : "boolean"
        },
        "excludes" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        },
        "includes" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        },
        "mode" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.SourceFieldMode"
          } ]
        }
      }
    },
    "_types.Uuid" : {
      "type" : "string"
    },
    "indices._types.Queries" : {
      "type" : "object",
      "properties" : {
        "cache" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.CacheQueries"
          } ]
        }
      }
    },
    "indices._types.SoftDeletes" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "description" : "Indicates whether soft deletes are enabled on the index.",
          "default" : true,
          "type" : "boolean"
        },
        "retention_lease" : {
          "description" : "The maximum period to retain a shard history retention lease before it is considered expired.\nShard history retention leases ensure that soft deletes are retained during merges on the Lucene\nindex. If a soft delete is merged away before it can be replicated to a follower the following\nprocess will fail due to incomplete history on the leader.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.RetentionLease"
          } ]
        }
      }
    },
    "_types.mapping.DynamicTemplate" : {
      "allOf" : [ {
        "type" : "object",
        "properties" : {
          "match" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            } ],
            "examples" : [ "long_*" ]
          },
          "path_match" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            } ],
            "examples" : [ "name.*" ]
          },
          "unmatch" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            } ],
            "examples" : [ "*_text" ]
          },
          "path_unmatch" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            } ],
            "examples" : [ "*.name" ]
          },
          "match_mapping_type" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            } ],
            "enum" : [ "boolean", "date", "double", "long", "object", "string", "*" ]
          },
          "unmatch_mapping_type" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            } ],
            "enum" : [ "boolean", "date", "double", "long", "object", "string", "*" ]
          },
          "match_pattern" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.MatchType"
            } ]
          }
        }
      }, {
        "type" : "object",
        "properties" : {
          "mapping" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.Property"
            } ]
          },
          "runtime" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.RuntimeField"
            } ]
          }
        },
        "minProperties" : 1,
        "maxProperties" : 10
      } ]
    },
    "indices._types.IndexVersioning" : {
      "type" : "object",
      "properties" : {
        "created" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        },
        "created_string" : {
          "type" : "string"
        }
      }
    },
    "indices._types.DataStreamFailureStoreTemplate" : {
      "description" : "Template equivalent of DataStreamFailureStore that allows nullable values.",
      "type" : "object",
      "properties" : {
        "enabled" : {
          "description" : "If defined, it turns the failure store on/off (`true`/`false`) for this data stream. A data stream failure store\nthat's disabled (enabled: `false`) will redirect no new failed indices to the failure store; however, it will\nnot remove any existing data from the failure store.",
          "default" : "true",
          "oneOf" : [ {
            "type" : "boolean"
          }, {
            "nullable" : true,
            "type" : "string"
          } ]
        },
        "lifecycle" : {
          "description" : "If defined, it specifies the lifecycle configuration for the failure store of this data stream.",
          "oneOf" : [ {
            "$ref" : "#/definitions/indices._types.FailureStoreLifecycleTemplate"
          }, {
            "nullable" : true,
            "type" : "string"
          } ]
        }
      }
    },
    "indices._types.SettingsSimilarity" : {
      "discriminator" : {
        "propertyName" : "type",
        "mapping" : {
          "BM25" : "#/components/schemas/indices._types.SettingsSimilarityBm25",
          "DFI" : "#/components/schemas/indices._types.SettingsSimilarityDfi",
          "DFR" : "#/components/schemas/indices._types.SettingsSimilarityDfr",
          "IB" : "#/components/schemas/indices._types.SettingsSimilarityIb",
          "LMDirichlet" : "#/components/schemas/indices._types.SettingsSimilarityLmd",
          "LMJelinekMercer" : "#/components/schemas/indices._types.SettingsSimilarityLmj",
          "boolean" : "#/components/schemas/indices._types.SettingsSimilarityBoolean",
          "scripted" : "#/components/schemas/indices._types.SettingsSimilarityScripted"
        }
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityBm25"
      }, {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityBoolean"
      }, {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityDfi"
      }, {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityDfr"
      }, {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityIb"
      }, {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityLmd"
      }, {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityLmj"
      }, {
        "$ref" : "#/definitions/indices._types.SettingsSimilarityScripted"
      } ]
    },
    "_types.mapping.AllField" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "type" : "string"
        },
        "enabled" : {
          "type" : "boolean"
        },
        "omit_norms" : {
          "type" : "boolean"
        },
        "search_analyzer" : {
          "type" : "string"
        },
        "similarity" : {
          "type" : "string"
        },
        "store" : {
          "type" : "boolean"
        },
        "store_term_vector_offsets" : {
          "type" : "boolean"
        },
        "store_term_vector_payloads" : {
          "type" : "boolean"
        },
        "store_term_vector_positions" : {
          "type" : "boolean"
        },
        "store_term_vectors" : {
          "type" : "boolean"
        }
      },
      "required" : [ "analyzer", "enabled", "omit_norms", "search_analyzer", "similarity", "store", "store_term_vector_offsets", "store_term_vector_payloads", "store_term_vector_positions", "store_term_vectors" ]
    },
    "_types.mapping.Property" : {
      "discriminator" : {
        "propertyName" : "type",
        "mapping" : {
          "aggregate_metric_double" : "#/components/schemas/_types.mapping.AggregateMetricDoubleProperty",
          "alias" : "#/components/schemas/_types.mapping.FieldAliasProperty",
          "binary" : "#/components/schemas/_types.mapping.BinaryProperty",
          "boolean" : "#/components/schemas/_types.mapping.BooleanProperty",
          "byte" : "#/components/schemas/_types.mapping.ByteNumberProperty",
          "completion" : "#/components/schemas/_types.mapping.CompletionProperty",
          "constant_keyword" : "#/components/schemas/_types.mapping.ConstantKeywordProperty",
          "counted_keyword" : "#/components/schemas/_types.mapping.CountedKeywordProperty",
          "date" : "#/components/schemas/_types.mapping.DateProperty",
          "date_nanos" : "#/components/schemas/_types.mapping.DateNanosProperty",
          "date_range" : "#/components/schemas/_types.mapping.DateRangeProperty",
          "dense_vector" : "#/components/schemas/_types.mapping.DenseVectorProperty",
          "double" : "#/components/schemas/_types.mapping.DoubleNumberProperty",
          "double_range" : "#/components/schemas/_types.mapping.DoubleRangeProperty",
          "flattened" : "#/components/schemas/_types.mapping.FlattenedProperty",
          "float" : "#/components/schemas/_types.mapping.FloatNumberProperty",
          "float_range" : "#/components/schemas/_types.mapping.FloatRangeProperty",
          "geo_point" : "#/components/schemas/_types.mapping.GeoPointProperty",
          "geo_shape" : "#/components/schemas/_types.mapping.GeoShapeProperty",
          "half_float" : "#/components/schemas/_types.mapping.HalfFloatNumberProperty",
          "histogram" : "#/components/schemas/_types.mapping.HistogramProperty",
          "icu_collation_keyword" : "#/components/schemas/_types.mapping.IcuCollationProperty",
          "integer" : "#/components/schemas/_types.mapping.IntegerNumberProperty",
          "integer_range" : "#/components/schemas/_types.mapping.IntegerRangeProperty",
          "ip" : "#/components/schemas/_types.mapping.IpProperty",
          "ip_range" : "#/components/schemas/_types.mapping.IpRangeProperty",
          "join" : "#/components/schemas/_types.mapping.JoinProperty",
          "keyword" : "#/components/schemas/_types.mapping.KeywordProperty",
          "long" : "#/components/schemas/_types.mapping.LongNumberProperty",
          "long_range" : "#/components/schemas/_types.mapping.LongRangeProperty",
          "match_only_text" : "#/components/schemas/_types.mapping.MatchOnlyTextProperty",
          "murmur3" : "#/components/schemas/_types.mapping.Murmur3HashProperty",
          "nested" : "#/components/schemas/_types.mapping.NestedProperty",
          "object" : "#/components/schemas/_types.mapping.ObjectProperty",
          "passthrough" : "#/components/schemas/_types.mapping.PassthroughObjectProperty",
          "percolator" : "#/components/schemas/_types.mapping.PercolatorProperty",
          "point" : "#/components/schemas/_types.mapping.PointProperty",
          "rank_feature" : "#/components/schemas/_types.mapping.RankFeatureProperty",
          "rank_features" : "#/components/schemas/_types.mapping.RankFeaturesProperty",
          "rank_vectors" : "#/components/schemas/_types.mapping.RankVectorProperty",
          "scaled_float" : "#/components/schemas/_types.mapping.ScaledFloatNumberProperty",
          "search_as_you_type" : "#/components/schemas/_types.mapping.SearchAsYouTypeProperty",
          "semantic_text" : "#/components/schemas/_types.mapping.SemanticTextProperty",
          "shape" : "#/components/schemas/_types.mapping.ShapeProperty",
          "short" : "#/components/schemas/_types.mapping.ShortNumberProperty",
          "sparse_vector" : "#/components/schemas/_types.mapping.SparseVectorProperty",
          "text" : "#/components/schemas/_types.mapping.TextProperty",
          "token_count" : "#/components/schemas/_types.mapping.TokenCountProperty",
          "unsigned_long" : "#/components/schemas/_types.mapping.UnsignedLongNumberProperty",
          "version" : "#/components/schemas/_types.mapping.VersionProperty",
          "wildcard" : "#/components/schemas/_types.mapping.WildcardProperty",
          "{dynamic_type}" : "#/components/schemas/_types.mapping.DynamicProperty"
        }
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.mapping.BinaryProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.BooleanProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.DynamicProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.JoinProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.KeywordProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.MatchOnlyTextProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.PercolatorProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.RankFeatureProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.RankFeaturesProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.SearchAsYouTypeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.TextProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.VersionProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.WildcardProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.DateNanosProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.DateProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.AggregateMetricDoubleProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.DenseVectorProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.FlattenedProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.NestedProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.ObjectProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.PassthroughObjectProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.RankVectorProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.SemanticTextProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.SparseVectorProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.CompletionProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.ConstantKeywordProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.CountedKeywordProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.FieldAliasProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.HistogramProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.IpProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.Murmur3HashProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.TokenCountProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.GeoPointProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.GeoShapeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.PointProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.ShapeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.ByteNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.DoubleNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.FloatNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.HalfFloatNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.IntegerNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.LongNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.ScaledFloatNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.ShortNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.UnsignedLongNumberProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.DateRangeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.DoubleRangeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.FloatRangeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.IntegerRangeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.IpRangeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.LongRangeProperty"
      }, {
        "$ref" : "#/definitions/_types.mapping.IcuCollationProperty"
      } ],
      "defaultSnippets" : [ {
        "label" : "add new property",
        "body" : {
          "type" : "$1"
        }
      } ]
    },
    "indices._types.Storage" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.StorageType"
          } ]
        },
        "allow_mmap" : {
          "description" : "You can restrict the use of the mmapfs and the related hybridfs store type via the setting node.store.allow_mmap.\nThis is a boolean setting indicating whether or not memory-mapping is allowed. The default is to allow it. This\nsetting is useful, for example, if you are in an environment where you can not control the ability to create a lot\nof memory maps so you need disable the ability to use memory-mapping.",
          "type" : "boolean"
        },
        "stats_refresh_interval" : {
          "description" : "How often store statistics are refreshed",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.PipelineName" : {
      "type" : "string"
    },
    "_types.mapping.FieldNamesField" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean",
          "default" : true
        }
      },
      "required" : [ "enabled" ]
    },
    "_types.mapping.SizeField" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean"
        }
      },
      "required" : [ "enabled" ]
    },
    "_types.Routing" : {
      "type" : "string"
    },
    "_types.Duration" : {
      "externalDocs" : {
        "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/api-conventions.html#time-units"
      },
      "description" : "A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and\n`d` (days). Also accepts \"0\" without a unit and \"-1\" to indicate an unspecified value.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "string",
        "enum" : [ "-1" ]
      }, {
        "type" : "string",
        "enum" : [ "0" ]
      } ],
      "examples" : [ "1s" ]
    },
    "indices._types.MappingLimitSettings" : {
      "description" : "Mapping Limit Settings",
      "type" : "object",
      "properties" : {
        "coerce" : {
          "type" : "boolean"
        },
        "total_fields" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettingsTotalFields"
          } ]
        },
        "depth" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettingsDepth"
          } ]
        },
        "nested_fields" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettingsNestedFields"
          } ]
        },
        "nested_objects" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettingsNestedObjects"
          } ]
        },
        "field_name_length" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettingsFieldNameLength"
          } ]
        },
        "dimension_fields" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettingsDimensionFields"
          } ]
        },
        "source" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.MappingLimitSettingsSourceFields"
          } ],
          "description" : "Since Elasticsearch 8.16.0"
        },
        "ignore_malformed" : {
          "oneOf" : [ {
            "type" : "boolean"
          }, {
            "type" : "string"
          } ],
          "examples" : [ true, false ]
        }
      }
    },
    "indices._types.IndexingSlowlogSettings" : {
      "type" : "object",
      "properties" : {
        "level" : {
          "type" : "string",
          "description" : "Removed since Elasticsearch 8.0.0",
          "default" : "TRACE"
        },
        "source" : {
          "type" : "number",
          "default" : "1000"
        },
        "reformat" : {
          "type" : "boolean",
          "default" : "true"
        },
        "threshold" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexingSlowlogTresholds"
          } ]
        }
      }
    },
    "_types.mapping.RoutingField" : {
      "type" : "object",
      "properties" : {
        "required" : {
          "default" : false
        }
      },
      "required" : [ "required" ]
    },
    "_types.DateTime" : {
      "description" : "A date and time, either as a string whose format can depend on the context (defaulting to ISO 8601), or a\nnumber of milliseconds since the Epoch. Elasticsearch accepts both as input, but will generally output a string\nrepresentation.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "$ref" : "#/definitions/_types.EpochTimeUnitMillis"
      } ]
    },
    "indices._types.IndexCheckOnStartup" : {
      "type" : "string",
      "enum" : [ "true", "false", "checksum" ]
    },
    "_spec_utils.Stringifiedinteger" : {
      "description" : "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
      "oneOf" : [ {
        "type" : "number"
      }, {
        "type" : "string"
      } ]
    },
    "_types.mapping.DataStreamTimestamp" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean"
        }
      },
      "required" : [ "enabled" ]
    },
    "indices._types.IndexRouting" : {
      "type" : "object",
      "properties" : {
        "allocation" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRoutingAllocation"
          } ]
        },
        "rebalance" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRoutingRebalance"
          } ]
        }
      }
    },
    "_types.query_dsl.QueryContainer" : {
      "externalDocs" : {
        "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl.html"
      },
      "description" : "An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.",
      "type" : "object",
      "properties" : {
        "bool" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-bool-query.html"
          },
          "description" : "matches documents matching boolean combinations of other queries.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.BoolQuery"
          } ]
        },
        "boosting" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-boosting-query.html"
          },
          "description" : "Returns documents matching a `positive` query while reducing the relevance score of documents that also match a `negative` query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.BoostingQuery"
          } ]
        },
        "common" : {
          "deprecated" : true,
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.CommonTermsQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "combined_fields" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-combined-fields-query.html"
          },
          "description" : "Since Elasticsearch 7.13.0\nThe `combined_fields` query supports searching multiple text fields as if their contents had been indexed into one combined field.",
          "x-state" : "Generally available; Added in 7.13.0",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.CombinedFieldsQuery"
          } ]
        },
        "constant_score" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-constant-score-query.html"
          },
          "description" : "Wraps a filter query and returns every matching document with a relevance score equal to the `boost` parameter value.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.ConstantScoreQuery"
          } ]
        },
        "dis_max" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-dis-max-query.html"
          },
          "description" : "Returns documents matching one or more wrapped queries, called query clauses or clauses.\nIf a returned document matches multiple query clauses, the `dis_max` query assigns the document the highest relevance score from any matching clause, plus a tie breaking increment for any additional matching subqueries.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.DisMaxQuery"
          } ]
        },
        "distance_feature" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-distance-feature-query.html"
          },
          "description" : "Boosts the relevance score of documents closer to a provided origin date or point.\nFor example, you can use this query to give more weight to documents closer to a certain date or location.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.DistanceFeatureQuery"
          } ]
        },
        "exists" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-exists-query.html"
          },
          "description" : "Returns documents that contain an indexed value for a field.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.ExistsQuery"
          } ]
        },
        "function_score" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-function-score-query.html"
          },
          "description" : "The `function_score` enables you to modify the score of documents that are retrieved by a query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.FunctionScoreQuery"
          } ]
        },
        "fuzzy" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-fuzzy-query.html"
          },
          "description" : "Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.FuzzyQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "geo_bounding_box" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-geo-bounding-box-query.html"
          },
          "description" : "Matches geo_point and geo_shape values that intersect a bounding box.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.GeoBoundingBoxQuery"
          } ]
        },
        "geo_distance" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-geo-distance-query.html"
          },
          "description" : "Matches `geo_point` and `geo_shape` values within a given distance of a geopoint.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.GeoDistanceQuery"
          } ]
        },
        "geo_grid" : {
          "description" : "Matches `geo_point` and `geo_shape` values that intersect a grid cell from a GeoGrid aggregation.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.GeoGridQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "geo_polygon" : {
          "deprecated" : true,
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.GeoPolygonQuery"
          } ]
        },
        "geo_shape" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-geo-shape-query.html"
          },
          "description" : "Filter documents indexed using either the `geo_shape` or the `geo_point` type.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.GeoShapeQuery"
          } ]
        },
        "has_child" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-has-child-query.html"
          },
          "description" : "Returns parent documents whose joined child documents match a provided query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.HasChildQuery"
          } ]
        },
        "has_parent" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-has-parent-query.html"
          },
          "description" : "Returns child documents whose joined parent document matches a provided query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.HasParentQuery"
          } ]
        },
        "ids" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-ids-query.html"
          },
          "description" : "Returns documents based on their IDs.\nThis query uses document IDs stored in the `_id` field.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IdsQuery"
          } ]
        },
        "intervals" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-intervals-query.html"
          },
          "description" : "Returns documents based on the order and proximity of matching terms.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "knn" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-knn-query.html"
          },
          "description" : "Finds the k nearest vectors to a query vector, as measured by a similarity\nmetric. knn query finds nearest vectors through approximate search on indexed\ndense_vectors.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.KnnQuery"
          } ]
        },
        "match" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-match-query.html"
          },
          "description" : "Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.MatchQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "match_all" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-match-all-query.html"
          },
          "description" : "Matches all documents, giving them all a `_score` of 1.0.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MatchAllQuery"
          } ]
        },
        "match_bool_prefix" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-match-bool-prefix-query.html"
          },
          "description" : "Analyzes its input and constructs a `bool` query from the terms.\nEach term except the last is used in a `term` query.\nThe last term is used in a prefix query.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.MatchBoolPrefixQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "match_none" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-match-all-query.html#query-dsl-match-none-query"
          },
          "description" : "Matches no documents.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MatchNoneQuery"
          } ]
        },
        "match_phrase" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-match-query-phrase.html"
          },
          "description" : "Analyzes the text and creates a phrase query out of the analyzed text.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.MatchPhraseQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "match_phrase_prefix" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-match-query-phrase-prefix.html"
          },
          "description" : "Returns documents that contain the words of a provided text, in the same order as provided.\nThe last term of the provided text is treated as a prefix, matching any words that begin with that term.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.MatchPhrasePrefixQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "more_like_this" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-mlt-query.html"
          },
          "description" : "Returns documents that are \"like\" a given set of documents.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MoreLikeThisQuery"
          } ]
        },
        "multi_match" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-multi-match-query.html"
          },
          "description" : "Enables you to search for a provided text, number, date or boolean value across multiple fields.\nThe provided text is analyzed before matching.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MultiMatchQuery"
          } ]
        },
        "nested" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-nested-query.html"
          },
          "description" : "Wraps another query to search nested fields.\nIf an object matches the search, the nested query returns the root parent document.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.NestedQuery"
          } ]
        },
        "parent_id" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-parent-id-query.html"
          },
          "description" : "Returns child documents joined to a specific parent document.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.ParentIdQuery"
          } ]
        },
        "percolate" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-percolate-query.html"
          },
          "description" : "Matches queries stored in an index.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.PercolateQuery"
          } ]
        },
        "pinned" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-pinned-query.html"
          },
          "description" : "Promotes selected documents to rank higher than those matching a given query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.PinnedQuery"
          } ]
        },
        "prefix" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-prefix-query.html"
          },
          "description" : "Returns documents that contain a specific prefix in a provided field.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.PrefixQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "query_string" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-query-string-query.html"
          },
          "description" : "Returns documents based on a provided query string, using a parser with a strict syntax.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.QueryStringQuery"
          } ]
        },
        "range" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-range-query.html"
          },
          "description" : "Returns documents that contain terms within a provided range.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.RangeQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "rank_feature" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-rank-feature-query.html"
          },
          "description" : "Boosts the relevance score of documents based on the numeric value of a `rank_feature` or `rank_features` field.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.RankFeatureQuery"
          } ]
        },
        "regexp" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-regexp-query.html"
          },
          "description" : "Returns documents that contain terms matching a regular expression.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.RegexpQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "rule" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.RuleQuery"
          } ]
        },
        "script" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-script-query.html"
          },
          "description" : "Filters documents based on a provided script.\nThe script query is typically used in a filter context.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.ScriptQuery"
          } ]
        },
        "script_score" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-script-score-query.html"
          },
          "description" : "Uses a script to provide a custom score for returned documents.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.ScriptScoreQuery"
          } ]
        },
        "semantic" : {
          "description" : "Since Elasticsearch 8.15.0\nA semantic query to semantic_text field types",
          "x-state" : "Generally available; Added in 8.15.0",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SemanticQuery"
          } ]
        },
        "shape" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-shape-query.html"
          },
          "description" : "Queries documents that contain fields indexed using the `shape` type.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.ShapeQuery"
          } ]
        },
        "simple_query_string" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-simple-query-string-query.html"
          },
          "description" : "Returns documents based on a provided query string, using a parser with a limited but fault-tolerant syntax.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SimpleQueryStringQuery"
          } ]
        },
        "span_containing" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-containing-query.html"
          },
          "description" : "Returns matches which enclose another span query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanContainingQuery"
          } ]
        },
        "span_field_masking" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-field-masking-query.html"
          },
          "description" : "Wrapper to allow span queries to participate in composite single-field span queries by _lying_ about their search field.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanFieldMaskingQuery"
          } ]
        },
        "span_first" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-first-query.html"
          },
          "description" : "Matches spans near the beginning of a field.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanFirstQuery"
          } ]
        },
        "span_multi" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-multi-term-query.html"
          },
          "description" : "Allows you to wrap a multi term query (one of `wildcard`, `fuzzy`, `prefix`, `range`, or `regexp` query) as a `span` query, so it can be nested.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanMultiTermQuery"
          } ]
        },
        "span_near" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-near-query.html"
          },
          "description" : "Matches spans which are near one another.\nYou can specify `slop`, the maximum number of intervening unmatched positions, as well as whether matches are required to be in-order.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanNearQuery"
          } ]
        },
        "span_not" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-not-query.html"
          },
          "description" : "Removes matches which overlap with another span query or which are within x tokens before (controlled by the parameter `pre`) or y tokens after (controlled by the parameter `post`) another span query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanNotQuery"
          } ]
        },
        "span_or" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-or-query.html"
          },
          "description" : "Matches the union of its span clauses.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanOrQuery"
          } ]
        },
        "span_term" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-term-query.html"
          },
          "description" : "Matches spans containing a term.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.SpanTermQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "span_within" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-span-within-query.html"
          },
          "description" : "Returns matches which are enclosed inside another span query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanWithinQuery"
          } ]
        },
        "sparse_vector" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-sparse-vector-query.html"
          },
          "description" : "Since Elasticsearch 8.15.0\nUsing input query vectors or a natural language processing model to convert a query into a list of token-weight pairs, queries against a sparse vector field.",
          "x-state" : "Generally available; Added in 8.15.0",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SparseVectorQuery"
          } ]
        },
        "term" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-term-query.html"
          },
          "description" : "Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.TermQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "terms" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-terms-query.html"
          },
          "description" : "Returns documents that contain one or more exact terms in a provided field.\nTo return a document, one or more terms must exactly match a field value, including whitespace and capitalization.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.TermsQuery"
          } ]
        },
        "terms_set" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-terms-set-query.html"
          },
          "description" : "Returns documents that contain a minimum number of exact terms in a provided field.\nTo return a document, a required number of terms must exactly match the field values, including whitespace and capitalization.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.TermsSetQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "text_expansion" : {
          "deprecated" : true,
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-text-expansion-query.html"
          },
          "description" : "Since Elasticsearch 8.8.0\nUses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a sparse vector or rank features field.",
          "x-state" : "Generally available; Added in 8.8.0",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.TextExpansionQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "weighted_tokens" : {
          "deprecated" : true,
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-weighted-tokens-query.html"
          },
          "description" : "Since Elasticsearch 8.13.0\nSupports returning text_expansion query results by sending in precomputed tokens with the query.",
          "x-state" : "Generally available; Added in 8.13.0",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.WeightedTokensQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "wildcard" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-wildcard-query.html"
          },
          "description" : "Returns documents that contain terms matching a wildcard pattern.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.WildcardQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "wrapper" : {
          "externalDocs" : {
            "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-wrapper-query.html"
          },
          "description" : "A query that accepts any other query as base64 encoded string.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.WrapperQuery"
          } ]
        },
        "type" : {
          "deprecated" : true,
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.TypeQuery"
          } ]
        }
      },
      "minProperties" : 1,
      "maxProperties" : 1
    },
    "indices._types.IndexSegmentSort" : {
      "type" : "object",
      "properties" : {
        "field" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Fields"
          } ]
        },
        "order" : {
          "oneOf" : [ {
            "$ref" : "#/definitions/indices._types.SegmentSortOrder"
          }, {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/indices._types.SegmentSortOrder"
            }
          } ]
        },
        "mode" : {
          "oneOf" : [ {
            "$ref" : "#/definitions/indices._types.SegmentSortMode"
          }, {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/indices._types.SegmentSortMode"
            }
          } ]
        },
        "missing" : {
          "oneOf" : [ {
            "$ref" : "#/definitions/indices._types.SegmentSortMissing"
          }, {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/indices._types.SegmentSortMissing"
            }
          } ]
        }
      }
    },
    "indices._types.SettingsQueryString" : {
      "type" : "object",
      "properties" : {
        "lenient" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
          } ]
        }
      },
      "required" : [ "lenient" ]
    },
    "indices._types.SettingsAnalyze" : {
      "type" : "object",
      "properties" : {
        "max_token_count" : {
          "default" : "10000",
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
          } ]
        }
      }
    },
    "indices._types.IndexSettingsAnalysis" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.analysis.Analyzer"
          },
          "defaultSnippets" : [ {
            "label" : "add new analyzer",
            "body" : {
              "${1:analyzer1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "char_filter" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.analysis.CharFilter"
          },
          "defaultSnippets" : [ {
            "label" : "add new char filter",
            "body" : {
              "${1:char_filter1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "filter" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.analysis.TokenFilter"
          },
          "defaultSnippets" : [ {
            "label" : "add new filter",
            "body" : {
              "${1:filter1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "normalizer" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.analysis.Normalizer"
          },
          "defaultSnippets" : [ {
            "label" : "add new normalizer",
            "body" : {
              "${1:normalizer1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "tokenizer" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.analysis.Tokenizer"
          },
          "defaultSnippets" : [ {
            "label" : "add new tokenizer",
            "body" : {
              "${1:tokenizer1}" : {
                "type" : "$2"
              }
            }
          } ]
        }
      }
    },
    "_types.mapping.IndexField" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean"
        }
      },
      "required" : [ "enabled" ]
    },
    "indices._types.DownsamplingRound" : {
      "type" : "object",
      "properties" : {
        "after" : {
          "description" : "The duration since rollover when this downsampling round should execute",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        },
        "config" : {
          "description" : "The downsample configuration to execute.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.DownsampleConfig"
          } ]
        }
      },
      "required" : [ "after", "config" ]
    },
    "_types.mapping.Subobjects" : {
      "type" : "string",
      "enum" : [ "true", "false" ],
      "description" : "Since Elasticsearch 8.3.0",
      "default" : "true"
    },
    "indices._types.IndexingPressure" : {
      "type" : "object",
      "properties" : {
        "memory" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexingPressureMemory"
          } ]
        }
      },
      "required" : [ "memory" ]
    },
    "_spec_utils.NullValue" : {
      "nullable" : true,
      "description" : "A `null` value that is to be interpreted as an actual value, unless other uses of `null` that are equivalent\nto a missing value. It is used for exemple in settings, where using the `NullValue` for a setting will reset\nit to its default value.",
      "type" : "string"
    },
    "indices._types.SettingsSearch" : {
      "type" : "object",
      "properties" : {
        "idle" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SearchIdle"
          } ]
        },
        "slowlog" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SlowlogSettings"
          } ]
        }
      }
    },
    "_spec_utils.StringifiedEpochTimeUnitMillis" : {
      "description" : "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.EpochTimeUnitMillis"
      }, {
        "type" : "string"
      } ]
    },
    "_types.analysis.Analyzer" : {
      "discriminator" : {
        "propertyName" : "type",
        "mapping" : {
          "arabic" : "#/components/schemas/_types.analysis.ArabicAnalyzer",
          "armenian" : "#/components/schemas/_types.analysis.ArmenianAnalyzer",
          "basque" : "#/components/schemas/_types.analysis.BasqueAnalyzer",
          "bengali" : "#/components/schemas/_types.analysis.BengaliAnalyzer",
          "brazilian" : "#/components/schemas/_types.analysis.BrazilianAnalyzer",
          "bulgarian" : "#/components/schemas/_types.analysis.BulgarianAnalyzer",
          "catalan" : "#/components/schemas/_types.analysis.CatalanAnalyzer",
          "chinese" : "#/components/schemas/_types.analysis.ChineseAnalyzer",
          "cjk" : "#/components/schemas/_types.analysis.CjkAnalyzer",
          "custom" : "#/components/schemas/_types.analysis.CustomAnalyzer",
          "czech" : "#/components/schemas/_types.analysis.CzechAnalyzer",
          "danish" : "#/components/schemas/_types.analysis.DanishAnalyzer",
          "dutch" : "#/components/schemas/_types.analysis.DutchAnalyzer",
          "english" : "#/components/schemas/_types.analysis.EnglishAnalyzer",
          "estonian" : "#/components/schemas/_types.analysis.EstonianAnalyzer",
          "fingerprint" : "#/components/schemas/_types.analysis.FingerprintAnalyzer",
          "finnish" : "#/components/schemas/_types.analysis.FinnishAnalyzer",
          "french" : "#/components/schemas/_types.analysis.FrenchAnalyzer",
          "galician" : "#/components/schemas/_types.analysis.GalicianAnalyzer",
          "german" : "#/components/schemas/_types.analysis.GermanAnalyzer",
          "greek" : "#/components/schemas/_types.analysis.GreekAnalyzer",
          "hindi" : "#/components/schemas/_types.analysis.HindiAnalyzer",
          "hungarian" : "#/components/schemas/_types.analysis.HungarianAnalyzer",
          "icu_analyzer" : "#/components/schemas/_types.analysis.IcuAnalyzer",
          "indonesian" : "#/components/schemas/_types.analysis.IndonesianAnalyzer",
          "irish" : "#/components/schemas/_types.analysis.IrishAnalyzer",
          "italian" : "#/components/schemas/_types.analysis.ItalianAnalyzer",
          "keyword" : "#/components/schemas/_types.analysis.KeywordAnalyzer",
          "kuromoji" : "#/components/schemas/_types.analysis.KuromojiAnalyzer",
          "latvian" : "#/components/schemas/_types.analysis.LatvianAnalyzer",
          "lithuanian" : "#/components/schemas/_types.analysis.LithuanianAnalyzer",
          "nori" : "#/components/schemas/_types.analysis.NoriAnalyzer",
          "norwegian" : "#/components/schemas/_types.analysis.NorwegianAnalyzer",
          "pattern" : "#/components/schemas/_types.analysis.PatternAnalyzer",
          "persian" : "#/components/schemas/_types.analysis.PersianAnalyzer",
          "portuguese" : "#/components/schemas/_types.analysis.PortugueseAnalyzer",
          "romanian" : "#/components/schemas/_types.analysis.RomanianAnalyzer",
          "russian" : "#/components/schemas/_types.analysis.RussianAnalyzer",
          "serbian" : "#/components/schemas/_types.analysis.SerbianAnalyzer",
          "simple" : "#/components/schemas/_types.analysis.SimpleAnalyzer",
          "snowball" : "#/components/schemas/_types.analysis.SnowballAnalyzer",
          "sorani" : "#/components/schemas/_types.analysis.SoraniAnalyzer",
          "spanish" : "#/components/schemas/_types.analysis.SpanishAnalyzer",
          "standard" : "#/components/schemas/_types.analysis.StandardAnalyzer",
          "stop" : "#/components/schemas/_types.analysis.StopAnalyzer",
          "swedish" : "#/components/schemas/_types.analysis.SwedishAnalyzer",
          "thai" : "#/components/schemas/_types.analysis.ThaiAnalyzer",
          "turkish" : "#/components/schemas/_types.analysis.TurkishAnalyzer",
          "whitespace" : "#/components/schemas/_types.analysis.WhitespaceAnalyzer"
        }
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CustomAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.FingerprintAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.KeywordAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.NoriAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.PatternAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SimpleAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.StandardAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.StopAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.WhitespaceAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.IcuAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.KuromojiAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SnowballAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.ArabicAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.ArmenianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.BasqueAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.BengaliAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.BrazilianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.BulgarianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.CatalanAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.ChineseAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.CjkAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.CzechAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.DanishAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.DutchAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.EnglishAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.EstonianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.FinnishAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.FrenchAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.GalicianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.GermanAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.GreekAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.HindiAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.HungarianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.IndonesianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.IrishAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.ItalianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.LatvianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.LithuanianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.NorwegianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.PersianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.PortugueseAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.RomanianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.RussianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SerbianAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SoraniAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SpanishAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SwedishAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.TurkishAnalyzer"
      }, {
        "$ref" : "#/definitions/_types.analysis.ThaiAnalyzer"
      } ],
      "defaultSnippets" : [ {
        "label" : "add new analyzer",
        "body" : {
          "type" : "$1"
        }
      } ],
      "properties" : {
        "type" : {
          "type" : "string",
          "$ref" : "#/definitions/analyzer_examples"
        }
      }
    },
    "_types.mapping.ShortNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "short" ]
          },
          "null_value" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.short"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.SemanticQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "field" : {
            "description" : "The field to query, which must be a semantic_text field type",
            "type" : "string"
          },
          "query" : {
            "description" : "The query text",
            "type" : "string"
          }
        },
        "required" : [ "field", "query" ]
      } ]
    },
    "indices._types.MappingLimitSettingsDimensionFields" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "description" : "[preview] This functionality is in technical preview and may be changed or removed in a future release.\nElastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.",
          "type" : "number"
        }
      }
    },
    "_types.query_dsl.GeoBoundingBoxQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "deprecated" : true,
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.GeoExecution"
            } ]
          },
          "validation_method" : {
            "description" : "Set to `IGNORE_MALFORMED` to accept geo points with invalid latitude or longitude.\nSet to `COERCE` to also try to infer correct latitude or longitude.",
            "default" : "'strict'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.GeoValidationMethod"
            } ]
          },
          "ignore_unmapped" : {
            "description" : "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
            "default" : false,
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.query_dsl.RankFeatureQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "field" : {
            "description" : "`rank_feature` or `rank_features` field used to boost relevance scores.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "saturation" : {
            "description" : "Saturation function used to boost relevance scores based on the value of the rank feature `field`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunctionSaturation"
            } ]
          },
          "log" : {
            "description" : "Logarithmic function used to boost relevance scores based on the value of the rank feature `field`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunctionLogarithm"
            } ]
          },
          "linear" : {
            "description" : "Linear function used to boost relevance scores based on the value of the rank feature `field`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunctionLinear"
            } ]
          },
          "sigmoid" : {
            "description" : "Sigmoid function used to boost relevance scores based on the value of the rank feature `field`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunctionSigmoid"
            } ]
          }
        },
        "required" : [ "field" ]
      } ]
    },
    "_types.query_dsl.SparseVectorQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "externalDocs" : {
          "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-sparse-vector-query.html"
        },
        "allOf" : [ {
          "type" : "object",
          "properties" : {
            "field" : {
              "description" : "The name of the field that contains the token-weight pairs to be searched against.\nThis field must be a mapped sparse_vector field.",
              "allOf" : [ {
                "$ref" : "#/definitions/_types.Field"
              } ]
            },
            "query" : {
              "description" : "The query text you want to use for search.\nIf inference_id is specified, query must also be specified.",
              "type" : "string"
            },
            "prune" : {
              "description" : "Since Elasticsearch 8.15.0\nWhether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false",
              "x-state" : "Generally available; Added in 8.15.0",
              "type" : "boolean"
            },
            "pruning_config" : {
              "description" : "Since Elasticsearch 8.15.0\nOptional pruning configuration.\nIf enabled, this will omit non-significant tokens from the query in order to improve query performance.\nThis is only used if prune is set to true.\nIf prune is set to true but pruning_config is not specified, default values will be used.",
              "x-state" : "Generally available; Added in 8.15.0",
              "allOf" : [ {
                "$ref" : "#/definitions/_types.TokenPruningConfig"
              } ]
            }
          },
          "required" : [ "field" ]
        }, {
          "type" : "object",
          "properties" : {
            "query_vector" : {
              "description" : "Dictionary of precomputed sparse vectors and their associated weights.\nOnly one of inference_id or query_vector may be supplied in a request.",
              "type" : "object",
              "additionalProperties" : {
                "type" : "number"
              }
            },
            "inference_id" : {
              "description" : "The inference ID to use to convert the query text into token-weight pairs.\nIt must be the same inference ID that was used to create the tokens from the input text.\nOnly one of inference_id and query_vector is allowed.\nIf inference_id is specified, query must also be specified.\nOnly one of inference_id or query_vector may be supplied in a request.",
              "allOf" : [ {
                "$ref" : "#/definitions/_types.Id"
              } ]
            }
          },
          "minProperties" : 1,
          "maxProperties" : 1
        } ]
      } ]
    },
    "_types.analysis.TokenFilter" : {
      "externalDocs" : {
        "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/analysis-tokenfilters.html"
      },
      "oneOf" : [ {
        "type" : "string"
      }, {
        "$ref" : "#/definitions/_types.analysis.TokenFilterDefinition"
      } ]
    },
    "_types.query_dsl.DisMaxQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "queries" : {
            "description" : "One or more query clauses.\nReturned documents must match one or more of these queries.\nIf a document matches multiple queries, Elasticsearch uses the highest relevance score.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            }
          },
          "tie_breaker" : {
            "description" : "Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.",
            "default" : 0.0,
            "type" : "number"
          }
        },
        "required" : [ "queries" ]
      } ]
    },
    "_types.mapping.HistogramProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "histogram" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.CombinedFieldsQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "fields" : {
            "description" : "List of fields to search. Field wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.Field"
            }
          },
          "query" : {
            "description" : "Text to search for in the provided `fields`.\nThe `combined_fields` query analyzes the provided text before performing a search.",
            "type" : "string"
          },
          "auto_generate_synonyms_phrase_query" : {
            "description" : "If true, match phrase queries are automatically created for multi-term synonyms.",
            "default" : true,
            "type" : "boolean"
          },
          "operator" : {
            "description" : "Boolean logic used to interpret text in the query value.",
            "default" : "or",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.CombinedFieldsOperator"
            } ]
          },
          "minimum_should_match" : {
            "externalDocs" : {
              "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-minimum-should-match.html"
            },
            "description" : "Minimum number of clauses that must match for a document to be returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "zero_terms_query" : {
            "description" : "Indicates whether no documents are returned if the analyzer removes all tokens, such as when using a `stop` filter.",
            "default" : "none",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.CombinedFieldsZeroTerms"
            } ]
          }
        },
        "required" : [ "fields", "query" ]
      } ]
    },
    "_types.query_dsl.NestedQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_unmapped" : {
            "description" : "Indicates whether to ignore an unmapped path and not return any documents instead of an error.",
            "default" : false,
            "type" : "boolean"
          },
          "inner_hits" : {
            "description" : "If defined, each search hit will contain inner hits.",
            "allOf" : [ {
              "$ref" : "#/definitions/_global.search._types.InnerHits"
            } ]
          },
          "path" : {
            "description" : "Path to the nested object you wish to search.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "query" : {
            "description" : "Query you wish to run on nested objects in the path.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "score_mode" : {
            "description" : "How scores for matching child objects affect the root parent documentâ€™s relevance score.",
            "default" : "'avg'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.ChildScoreMode"
            } ]
          }
        },
        "required" : [ "path", "query" ]
      } ]
    },
    "_types.query_dsl.SpanWithinQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "big" : {
            "description" : "Can be any span query.\nMatching spans from `little` that are enclosed within `big` are returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          },
          "little" : {
            "description" : "Can be any span query.\nMatching spans from `little` that are enclosed within `big` are returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          }
        },
        "required" : [ "big", "little" ]
      } ]
    },
    "_types.mapping.BinaryProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "binary" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.FieldAliasProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "path" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "type" : {
            "type" : "string",
            "enum" : [ "alias" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.CommonTermsQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "type" : "string"
          },
          "cutoff_frequency" : {
            "type" : "number"
          },
          "high_freq_operator" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Operator"
            } ]
          },
          "low_freq_operator" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Operator"
            } ]
          },
          "minimum_should_match" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "query" : {
            "type" : "string"
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.mapping.GeoPointProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "ignore_z_value" : {
            "type" : "boolean"
          },
          "null_value" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.GeoLocation"
            } ]
          },
          "index" : {
            "type" : "boolean"
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "type" : {
            "type" : "string",
            "enum" : [ "geo_point" ]
          },
          "time_series_metric" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.GeoPointMetricType"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.MatchPhraseQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "description" : "Analyzer used to convert the text in the query value into tokens.",
            "type" : "string"
          },
          "query" : {
            "description" : "Query terms that are analyzed and turned into a phrase query.",
            "type" : "string"
          },
          "slop" : {
            "description" : "Maximum number of positions allowed between matching tokens.",
            "default" : 0.0,
            "type" : "number"
          },
          "zero_terms_query" : {
            "description" : "Indicates whether no documents are returned if the `analyzer` removes all tokens, such as when using a `stop` filter.",
            "default" : "'none'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.ZeroTermsQuery"
            } ]
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.mapping.TextProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.CorePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "type" : "string",
            "$ref" : "#/definitions/analyzer_examples"
          },
          "boost" : {
            "type" : "number",
            "default" : 1.0
          },
          "eager_global_ordinals" : {
            "type" : "boolean"
          },
          "fielddata" : {
            "type" : "boolean"
          },
          "fielddata_frequency_filter" : {
            "allOf" : [ {
              "$ref" : "#/definitions/indices._types.FielddataFrequencyFilter"
            } ]
          },
          "index" : {
            "type" : "boolean"
          },
          "index_options" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.IndexOptions"
            } ]
          },
          "index_phrases" : {
            "type" : "boolean"
          },
          "index_prefixes" : {
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TextIndexPrefixes"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          },
          "norms" : {
            "type" : "boolean"
          },
          "position_increment_gap" : {
            "type" : "number"
          },
          "search_analyzer" : {
            "type" : "string",
            "$ref" : "#/definitions/analyzer_examples"
          },
          "search_quote_analyzer" : {
            "type" : "string",
            "$ref" : "#/definitions/analyzer_examples"
          },
          "similarity" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "nullable" : true,
              "type" : "string"
            } ],
            "examples" : [ "BM25", "boolean" ]
          },
          "term_vector" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TermVectorOption"
            } ]
          },
          "type" : {
            "type" : "string",
            "enum" : [ "text" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.IndexingSlowlogTresholds" : {
      "type" : "object",
      "properties" : {
        "index" : {
          "description" : "The indexing slow log, similar in functionality to the search slow log. The log file name ends with `_index_indexing_slowlog.json`.\nLog and the thresholds are configured in the same way as the search slowlog.",
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SlowlogTresholdLevels"
          } ]
        }
      }
    },
    "_types.mapping.SearchAsYouTypeProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.CorePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "type" : "string",
            "$ref" : "#/definitions/analyzer_examples"
          },
          "index" : {
            "type" : "boolean"
          },
          "index_options" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.IndexOptions"
            } ]
          },
          "max_shingle_size" : {
            "type" : "number"
          },
          "norms" : {
            "type" : "boolean"
          },
          "search_analyzer" : {
            "type" : "string",
            "$ref" : "#/definitions/analyzer_examples"
          },
          "search_quote_analyzer" : {
            "type" : "string",
            "$ref" : "#/definitions/analyzer_examples"
          },
          "similarity" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "nullable" : true,
              "type" : "string"
            } ],
            "examples" : [ "BM25", "boolean" ]
          },
          "term_vector" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TermVectorOption"
            } ]
          },
          "type" : {
            "type" : "string",
            "enum" : [ "search_as_you_type" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.FloatNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "float" ]
          },
          "null_value" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.RuntimeFieldType" : {
      "type" : "string",
      "enum" : [ "boolean", "composite", "date", "double", "geo_point", "geo_shape", "ip", "keyword", "long", "lookup" ]
    },
    "_types.query_dsl.GeoGridQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "geotile" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.GeoTile"
            } ]
          },
          "geohash" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.GeoHash"
            } ]
          },
          "geohex" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.GeoHexCell"
            } ]
          }
        },
        "minProperties" : 1,
        "maxProperties" : 1
      } ]
    },
    "_types.mapping.UnsignedLongNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "unsigned_long" ]
          },
          "null_value" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.ulong"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.MappingLimitSettingsDepth" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "description" : "The maximum depth for a field, which is measured as the number of inner objects. For instance, if all fields are defined\nat the root object level, then the depth is 1. If there is one object mapping, then the depth is 2, etc.",
          "default" : 20.0,
          "type" : "number"
        }
      }
    },
    "indices._types.IndexingPressureMemory" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "description" : "Number of outstanding bytes that may be consumed by indexing requests. When this limit is reached or exceeded,\nthe node will reject new coordinating and primary operations. When replica operations consume 1.5x this limit,\nthe node will reject new replica operations. Defaults to 10% of the heap.",
          "type" : "number"
        }
      }
    },
    "_types.mapping.CompositeSubField" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.RuntimeFieldType"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.ExistsQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "field" : {
            "description" : "Name of the field you wish to search.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          }
        },
        "required" : [ "field" ]
      } ]
    },
    "_types.mapping.DateNanosProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number"
          },
          "format" : {
            "type" : "string"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "null_value" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateTime"
            } ]
          },
          "precision_step" : {
            "type" : "number"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "date_nanos" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.DateRangeProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.RangePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "type" : "string"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "date_range" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.JoinProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "relations" : {
            "type" : "object",
            "additionalProperties" : {
              "oneOf" : [ {
                "$ref" : "#/definitions/_types.RelationName"
              }, {
                "type" : "array",
                "items" : {
                  "$ref" : "#/definitions/_types.RelationName"
                }
              } ]
            }
          },
          "eager_global_ordinals" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "join" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.MappingLimitSettingsTotalFields" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "description" : "The maximum number of fields in an index. Field and object mappings, as well as field aliases count towards this limit.\nThe limit is in place to prevent mappings and searches from becoming too large. Higher values can lead to performance\ndegradations and memory issues, especially in clusters with a high load or few resources.",
          "default" : "1000",
          "oneOf" : [ {
            "type" : "number"
          }, {
            "type" : "string"
          } ]
        },
        "ignore_dynamic_beyond_limit" : {
          "description" : "This setting determines what happens when a dynamically mapped field would exceed the total fields limit. When set\nto false (the default), the index request of the document that tries to add a dynamic field to the mapping will fail\nwith the message Limit of total fields [X] has been exceeded. When set to true, the index request will not fail.\nInstead, fields that would exceed the limit are not added to the mapping, similar to dynamic: false.\nThe fields that were not added to the mapping will be added to the _ignored field.",
          "default" : "false",
          "oneOf" : [ {
            "type" : "boolean"
          }, {
            "type" : "string"
          } ]
        }
      }
    },
    "_spec_utils.Stringifiedboolean" : {
      "description" : "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
      "oneOf" : [ {
        "type" : "boolean"
      }, {
        "type" : "string"
      } ]
    },
    "indices._types.SettingsSimilarityScripted" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "scripted" ]
        },
        "script" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Script"
          } ]
        },
        "weight_script" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Script"
          } ]
        }
      },
      "required" : [ "type", "script" ]
    },
    "indices._types.SegmentSortMode" : {
      "type" : "string",
      "enum" : [ "min", "MIN", "max", "MAX" ]
    },
    "_types.query_dsl.FuzzyQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "max_expansions" : {
            "description" : "Maximum number of variations created.",
            "default" : 50.0,
            "type" : "number"
          },
          "prefix_length" : {
            "description" : "Number of beginning characters left unchanged when creating expansions.",
            "default" : 0.0,
            "type" : "number"
          },
          "rewrite" : {
            "description" : "Number of beginning characters left unchanged when creating expansions.",
            "default" : "constant_score",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "transpositions" : {
            "description" : "Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`).",
            "default" : true,
            "type" : "boolean"
          },
          "fuzziness" : {
            "description" : "Maximum edit distance allowed for matching.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fuzziness"
            } ]
          },
          "value" : {
            "description" : "Term you wish to find in the provided field.",
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "number"
            }, {
              "type" : "boolean"
            } ]
          }
        },
        "required" : [ "value" ]
      } ]
    },
    "_types.VersionString" : {
      "type" : "string",
      "description" : "A string representing a version"
    },
    "_types.mapping.RankVectorProperty" : {
      "description" : "Technical preview",
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "rank_vectors" ]
          },
          "element_type" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.RankVectorElementType"
            } ]
          },
          "dims" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.IndexRoutingRebalance" : {
      "type" : "object",
      "properties" : {
        "enable" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRoutingRebalanceOptions"
          } ]
        }
      },
      "required" : [ "enable" ]
    },
    "_types.mapping.FloatRangeProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.RangePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "float_range" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.TextExpansionQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "model_id" : {
            "description" : "The text expansion NLP model to use",
            "type" : "string"
          },
          "model_text" : {
            "description" : "The query text",
            "type" : "string"
          },
          "pruning_config" : {
            "description" : "Since Elasticsearch 8.13.0\nToken pruning configurations",
            "x-state" : "Technical preview; Added in 8.13.0",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.TokenPruningConfig"
            } ]
          }
        },
        "required" : [ "model_id", "model_text" ]
      } ]
    },
    "indices._types.SegmentSortOrder" : {
      "type" : "string",
      "enum" : [ "asc", "ASC", "desc", "DESC" ]
    },
    "_types.mapping.AggregateMetricDoubleProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "aggregate_metric_double" ]
          },
          "default_metric" : {
            "type" : "string"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "metrics" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "time_series_metric" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TimeSeriesMetricType"
            } ]
          }
        },
        "required" : [ "type", "default_metric", "metrics" ]
      } ]
    },
    "indices._types.CacheQueries" : {
      "type" : "object",
      "properties" : {
        "enabled" : {
          "type" : "boolean"
        }
      },
      "required" : [ "enabled" ]
    },
    "indices._types.IndexSettingsLifecycleStep" : {
      "type" : "object",
      "properties" : {
        "wait_time_threshold" : {
          "description" : "Time to wait for the cluster to resolve allocation issues during an ILM shrink action. Must be greater than 1h (1 hour).\nSee Shard allocation for shrink.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        }
      }
    },
    "_types.mapping.MatchOnlyTextProperty" : {
      "description" : "A variant of text that trades scoring and efficiency of positional queries for space efficiency. This field\neffectively stores data the same way as a text field that only indexes documents (index_options: docs) and\ndisables norms (norms: false). Term queries perform as fast if not faster as on text fields, however queries\nthat need positions such as the match_phrase query perform slower as they need to look at the _source document\nto verify whether a phrase matches. All queries return constant scores that are equal to 1.0.",
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "match_only_text" ]
        },
        "fields" : {
          "description" : "Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.mapping.Property"
          }
        },
        "meta" : {
          "description" : "Metadata about the field.",
          "type" : "object",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "copy_to" : {
          "description" : "Allows you to copy the values of multiple fields into a group\nfield, which can then be queried as a single field.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Fields"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "indices._types.MappingLimitSettingsNestedFields" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "description" : "The maximum number of distinct nested mappings in an index. The nested type should only be used in special cases, when\narrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this\nsetting limits the number of unique nested types per index.",
          "default" : 50.0,
          "type" : "number"
        }
      }
    },
    "_types.mapping.MatchType" : {
      "type" : "string",
      "enum" : [ "simple", "regex" ]
    },
    "_types.query_dsl.TermsQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object"
      } ]
    },
    "_types.mapping.ScaledFloatNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "scaled_float" ]
          },
          "null_value" : {
            "type" : "number"
          },
          "scaling_factor" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.RankFeatureProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "positive_score_impact" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "rank_feature" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.SpanTermQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "value" : {
            "type" : "string"
          }
        },
        "required" : [ "value" ]
      } ]
    },
    "indices._types.SlowlogSettings" : {
      "type" : "object",
      "properties" : {
        "level" : {
          "type" : "string",
          "description" : "Removed since Elasticsearch 8.0.0",
          "default" : "TRACE"
        },
        "source" : {
          "type" : "number",
          "default" : "1000"
        },
        "reformat" : {
          "type" : "boolean",
          "default" : true
        },
        "threshold" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SlowlogTresholds"
          } ]
        }
      }
    },
    "_types.mapping.SourceFieldMode" : {
      "type" : "string",
      "enum" : [ "disabled", "stored", "synthetic" ]
    },
    "indices._types.RetentionLease" : {
      "type" : "object",
      "properties" : {
        "period" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        }
      },
      "required" : [ "period" ]
    },
    "_types.mapping.KeywordProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number",
            "default" : 1.0
          },
          "eager_global_ordinals" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          },
          "index_options" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.IndexOptions"
            } ]
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "normalizer" : {
            "type" : "string",
            "examples" : [ "lowercase" ]
          },
          "norms" : {
            "type" : "boolean"
          },
          "null_value" : {
            "type" : "string"
          },
          "similarity" : {
            "oneOf" : [ {
              "type" : "string"
            }, {
              "nullable" : true,
              "type" : "string"
            } ],
            "examples" : [ "BM25", "boolean" ]
          },
          "split_queries_on_whitespace" : {
            "type" : "boolean"
          },
          "time_series_dimension" : {
            "description" : "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
            "x-state" : "Technical preview",
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "keyword" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.QueryStringQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "allow_leading_wildcard" : {
            "description" : "If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string.",
            "default" : true,
            "type" : "boolean"
          },
          "analyzer" : {
            "description" : "Analyzer used to convert text in the query string into tokens.",
            "type" : "string"
          },
          "analyze_wildcard" : {
            "description" : "If `true`, the query attempts to analyze wildcard terms in the query string.",
            "default" : false,
            "type" : "boolean"
          },
          "auto_generate_synonyms_phrase_query" : {
            "description" : "If `true`, match phrase queries are automatically created for multi-term synonyms.",
            "default" : true,
            "type" : "boolean"
          },
          "default_field" : {
            "description" : "Default field to search if no field is provided in the query string.\nSupports wildcards (`*`).\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "default_operator" : {
            "description" : "Default boolean logic used to interpret text in the query string if no operators are specified.",
            "default" : "'or'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Operator"
            } ]
          },
          "enable_position_increments" : {
            "description" : "If `true`, enable position increments in queries constructed from a `query_string` search.",
            "default" : true,
            "type" : "boolean"
          },
          "escape" : {
            "default" : false,
            "type" : "boolean"
          },
          "fields" : {
            "description" : "Array of fields to search. Supports wildcards (`*`).",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.Field"
            }
          },
          "fuzziness" : {
            "description" : "Maximum edit distance allowed for fuzzy matching.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fuzziness"
            } ]
          },
          "fuzzy_max_expansions" : {
            "description" : "Maximum number of terms to which the query expands for fuzzy matching.",
            "default" : 50.0,
            "type" : "number"
          },
          "fuzzy_prefix_length" : {
            "description" : "Number of beginning characters left unchanged for fuzzy matching.",
            "default" : 0.0,
            "type" : "number"
          },
          "fuzzy_rewrite" : {
            "description" : "Method used to rewrite the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "fuzzy_transpositions" : {
            "description" : "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
            "default" : true,
            "type" : "boolean"
          },
          "lenient" : {
            "description" : "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
            "default" : false,
            "type" : "boolean"
          },
          "max_determinized_states" : {
            "description" : "Maximum number of automaton states required for the query.",
            "default" : 10000.0,
            "type" : "number"
          },
          "minimum_should_match" : {
            "description" : "Minimum number of clauses that must match for a document to be returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "phrase_slop" : {
            "description" : "Maximum number of positions allowed between matching tokens for phrases.",
            "default" : 0.0,
            "type" : "number"
          },
          "query" : {
            "description" : "Query string you wish to parse and use for search.",
            "type" : "string"
          },
          "quote_analyzer" : {
            "description" : "Analyzer used to convert quoted text in the query string into tokens.\nFor quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.",
            "type" : "string"
          },
          "quote_field_suffix" : {
            "description" : "Suffix appended to quoted text in the query string.\nYou can use this suffix to use a different analysis method for exact matches.",
            "type" : "string"
          },
          "rewrite" : {
            "description" : "Method used to rewrite the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "tie_breaker" : {
            "description" : "How to combine the queries generated from the individual search terms in the resulting `dis_max` query.",
            "type" : "number"
          },
          "time_zone" : {
            "description" : "Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.TimeZone"
            } ]
          },
          "type" : {
            "description" : "Determines how the query matches and scores documents.",
            "default" : "'best_fields'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.TextQueryType"
            } ]
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.mapping.IntegerNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "integer" ]
          },
          "null_value" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.BoolQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "filter" : {
            "description" : "The clause (query) must appear in matching documents.\nHowever, unlike `must`, the score of the query will be ignored.",
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
              }
            } ]
          },
          "minimum_should_match" : {
            "description" : "Specifies the number or percentage of `should` clauses returned documents must match.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "must" : {
            "description" : "The clause (query) must appear in matching documents and will contribute to the score.",
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
              }
            } ]
          },
          "must_not" : {
            "description" : "The clause (query) must not appear in the matching documents.\nBecause scoring is ignored, a score of `0` is returned for all documents.",
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
              }
            } ]
          },
          "should" : {
            "description" : "The clause (query) should appear in the matching document.",
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
              }
            } ]
          }
        }
      } ]
    },
    "_types.query_dsl.IdsQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "values" : {
            "description" : "An array of document IDs.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Ids"
            } ]
          }
        }
      } ]
    },
    "_types.query_dsl.TypeQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "value" : {
            "type" : "string"
          }
        },
        "required" : [ "value" ]
      } ]
    },
    "_types.mapping.LongRangeProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.RangePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "long_range" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.EpochTimeUnitMillis" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.UnitMillis"
      } ]
    },
    "_types.query_dsl.DistanceFeatureQuery" : {
      "externalDocs" : {
        "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-distance-feature-query.html"
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.UntypedDistanceFeatureQuery"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.GeoDistanceFeatureQuery"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.DateDistanceFeatureQuery"
      } ]
    },
    "_types.mapping.CompletionProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "type" : "string"
          },
          "contexts" : {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.mapping.SuggestContext"
            }
          },
          "max_input_length" : {
            "type" : "number"
          },
          "preserve_position_increments" : {
            "type" : "boolean"
          },
          "preserve_separators" : {
            "type" : "boolean"
          },
          "search_analyzer" : {
            "type" : "string"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "completion" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.IntervalsQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "externalDocs" : {
          "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-intervals-query.html"
        },
        "type" : "object",
        "properties" : {
          "all_of" : {
            "description" : "Returns matches that span a combination of other rules.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsAllOf"
            } ]
          },
          "any_of" : {
            "description" : "Returns intervals produced by any of its sub-rules.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsAnyOf"
            } ]
          },
          "fuzzy" : {
            "description" : "Matches terms that are similar to the provided term, within an edit distance defined by `fuzziness`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsFuzzy"
            } ]
          },
          "match" : {
            "description" : "Matches analyzed text.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsMatch"
            } ]
          },
          "prefix" : {
            "description" : "Matches terms that start with a specified set of characters.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsPrefix"
            } ]
          },
          "range" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsRange"
            } ]
          },
          "regexp" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsRegexp"
            } ]
          },
          "wildcard" : {
            "description" : "Matches terms using a wildcard pattern.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.IntervalsWildcard"
            } ]
          }
        },
        "minProperties" : 1,
        "maxProperties" : 1
      } ]
    },
    "_types.Field" : {
      "description" : "Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.",
      "type" : "string"
    },
    "_types.mapping.SemanticTextProperty" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "semantic_text" ]
        },
        "meta" : {
          "type" : "object",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "inference_id" : {
          "description" : "Inference endpoint that will be used to generate embeddings for the field.\nThis parameter cannot be updated. Use the Create inference API to create the endpoint.\nIf `search_inference_id` is specified, the inference endpoint will only be used at index time.",
          "default" : ".elser-2-elasticsearch",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Id"
          } ]
        },
        "search_inference_id" : {
          "description" : "Inference endpoint that will be used to generate embeddings at query time.\nYou can update this parameter by using the Update mapping API. Use the Create inference API to create the endpoint.\nIf not specified, the inference endpoint defined by inference_id will be used at both index and query time.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Id"
          } ]
        },
        "index_options" : {
          "description" : "Settings for index_options that override any defaults used by semantic_text, for example\nspecific quantization settings.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.SemanticTextIndexOptions"
          } ]
        },
        "chunking_settings" : {
          "description" : "Settings for chunking text into smaller passages. If specified, these will override the\nchunking settings sent in the inference endpoint associated with inference_id. If chunking settings are updated,\nthey will not be applied to existing documents until they are reindexed.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.ChunkingSettings"
          } ]
        },
        "fields" : {
          "description" : "Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.mapping.Property"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.IcuCollationProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "icu_collation_keyword" ]
          },
          "norms" : {
            "type" : "boolean"
          },
          "index_options" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.IndexOptions"
            } ]
          },
          "index" : {
            "description" : "Should the field be searchable?",
            "type" : "boolean"
          },
          "null_value" : {
            "description" : "Accepts a string value which is substituted for any explicit null values. Defaults to null, which means the field is treated as missing.",
            "type" : "string"
          },
          "rules" : {
            "type" : "string"
          },
          "language" : {
            "type" : "string"
          },
          "country" : {
            "type" : "string"
          },
          "variant" : {
            "type" : "string"
          },
          "strength" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationStrength"
            } ]
          },
          "decomposition" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationDecomposition"
            } ]
          },
          "alternate" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationAlternate"
            } ]
          },
          "case_level" : {
            "type" : "boolean"
          },
          "case_first" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationCaseFirst"
            } ]
          },
          "numeric" : {
            "type" : "boolean"
          },
          "variable_top" : {
            "type" : "string"
          },
          "hiragana_quaternary_mode" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.SpanContainingQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "big" : {
            "description" : "Can be any span query.\nMatching spans from `big` that contain matches from `little` are returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          },
          "little" : {
            "description" : "Can be any span query.\nMatching spans from `big` that contain matches from `little` are returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          }
        },
        "required" : [ "big", "little" ]
      } ]
    },
    "_types.KnnQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "field" : {
            "description" : "The name of the vector field to search against",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "query_vector" : {
            "description" : "The query vector",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.QueryVector"
            } ]
          },
          "query_vector_builder" : {
            "description" : "The query vector builder. You must provide a query_vector_builder or query_vector, but not both.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.QueryVectorBuilder"
            } ]
          },
          "num_candidates" : {
            "description" : "The number of nearest neighbor candidates to consider per shard",
            "type" : "number"
          },
          "k" : {
            "description" : "The final number of nearest neighbors to return as top hits",
            "type" : "number"
          },
          "filter" : {
            "description" : "Filters for the kNN search query",
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
              }
            } ]
          },
          "similarity" : {
            "description" : "The minimum similarity for a vector to be considered a match",
            "type" : "number"
          },
          "rescore_vector" : {
            "description" : "Since Elasticsearch 8.18.0\nApply oversampling and rescoring to quantized vectors *",
            "x-state" : "Technical preview; Added in 8.18.0",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.RescoreVector"
            } ]
          }
        },
        "required" : [ "field" ]
      } ]
    },
    "_types.query_dsl.ScriptQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "script" : {
            "description" : "Contains a script to run as a query.\nThis script must return a boolean value, `true` or `false`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          }
        },
        "required" : [ "script" ]
      } ]
    },
    "_types.mapping.CountedKeywordProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "counted_keyword" ]
          },
          "index" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.WrapperQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "query" : {
            "description" : "A base64 encoded query.\nThe binary data format can be any of JSON, YAML, CBOR or SMILE encodings",
            "type" : "string"
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "indices._types.SettingsSimilarityBoolean" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "boolean" ]
        }
      },
      "required" : [ "type" ]
    },
    "indices._types.SearchIdle" : {
      "type" : "object",
      "properties" : {
        "after" : {
          "default" : "30s",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        }
      }
    },
    "_types.mapping.ObjectProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.CorePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "subobjects" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.Subobjects"
            } ]
          },
          "type" : {
            "type" : "string",
            "enum" : [ "object" ]
          }
        }
      } ]
    },
    "_types.query_dsl.RuleQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "organic" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "ruleset_ids" : {
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.Id"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.Id"
              }
            } ]
          },
          "ruleset_id" : {
            "type" : "string"
          },
          "match_criteria" : {
            "type" : "object"
          }
        },
        "required" : [ "organic", "match_criteria" ]
      } ]
    },
    "indices._types.SegmentSortMissing" : {
      "type" : "string",
      "enum" : [ "_last", "_first" ]
    },
    "_types.query_dsl.TermsSetQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "minimum_should_match" : {
            "description" : "Since Elasticsearch 8.10.0\nSpecification describing number of matching terms required to return a document.",
            "x-state" : "Generally available; Added in 8.10.0",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "minimum_should_match_field" : {
            "description" : "Numeric field containing the number of matching terms required to return a document.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "minimum_should_match_script" : {
            "description" : "Custom script containing the number of matching terms required to return a document.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "terms" : {
            "description" : "Array of terms you wish to find in the provided field.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "terms" ]
      } ]
    },
    "_types.mapping.HalfFloatNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "half_float" ]
          },
          "null_value" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.RuntimeFieldFetchFields" : {
      "type" : "object",
      "properties" : {
        "field" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "format" : {
          "type" : "string"
        }
      },
      "required" : [ "field" ]
    },
    "_types.query_dsl.SpanMultiTermQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "match" : {
            "description" : "Should be a multi term query (one of `wildcard`, `fuzzy`, `prefix`, `range`, or `regexp` query).",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          }
        },
        "required" : [ "match" ]
      } ]
    },
    "indices._types.DownsampleConfig" : {
      "type" : "object",
      "properties" : {
        "fixed_interval" : {
          "description" : "The interval at which to aggregate the original time series index.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DurationLarge"
          } ]
        }
      },
      "required" : [ "fixed_interval" ]
    },
    "_types.mapping.DoubleRangeProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.RangePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "double_range" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.MatchNoneQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object"
      } ]
    },
    "_types.query_dsl.SpanFirstQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "end" : {
            "description" : "Controls the maximum end position permitted in a match.",
            "type" : "number"
          },
          "match" : {
            "description" : "Can be any other span type query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          }
        },
        "required" : [ "end", "match" ]
      } ]
    },
    "_types.query_dsl.MoreLikeThisQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "externalDocs" : {
              "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/analysis.html"
            },
            "description" : "The analyzer that is used to analyze the free form text.\nDefaults to the analyzer associated with the first field in fields.",
            "type" : "string"
          },
          "boost_terms" : {
            "description" : "Each term in the formed query could be further boosted by their tf-idf score.\nThis sets the boost factor to use when using this feature.\nDefaults to deactivated (0).",
            "default" : 0.0,
            "type" : "number"
          },
          "fail_on_unsupported_field" : {
            "description" : "Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`).",
            "default" : true,
            "type" : "boolean"
          },
          "fields" : {
            "description" : "A list of fields to fetch and analyze the text from.\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.Field"
            }
          },
          "include" : {
            "description" : "Specifies whether the input documents should also be included in the search results returned.",
            "default" : false,
            "type" : "boolean"
          },
          "like" : {
            "description" : "Specifies free form text and/or a single or multiple documents for which you want to find similar documents.",
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Like"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.Like"
              }
            } ]
          },
          "max_doc_freq" : {
            "description" : "The maximum document frequency above which the terms are ignored from the input document.",
            "type" : "number"
          },
          "max_query_terms" : {
            "description" : "The maximum number of query terms that can be selected.",
            "default" : 25.0,
            "type" : "number"
          },
          "max_word_length" : {
            "description" : "The maximum word length above which the terms are ignored.\nDefaults to unbounded (`0`).",
            "default" : 0.0,
            "type" : "number"
          },
          "min_doc_freq" : {
            "description" : "The minimum document frequency below which the terms are ignored from the input document.",
            "default" : 5.0,
            "type" : "number"
          },
          "minimum_should_match" : {
            "description" : "After the disjunctive query has been formed, this parameter controls the number of terms that must match.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "min_term_freq" : {
            "description" : "The minimum term frequency below which the terms are ignored from the input document.",
            "default" : 2.0,
            "type" : "number"
          },
          "min_word_length" : {
            "description" : "The minimum word length below which the terms are ignored.",
            "default" : 0.0,
            "type" : "number"
          },
          "routing" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Routing"
            } ]
          },
          "stop_words" : {
            "description" : "An array of stop words.\nAny word in this set is ignored.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.StopWords"
            } ]
          },
          "unlike" : {
            "description" : "Used in combination with `like` to exclude documents that match a set of terms.",
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Like"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.Like"
              }
            } ]
          },
          "version" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.VersionNumber"
            } ]
          },
          "version_type" : {
            "default" : "'internal'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.VersionType"
            } ]
          }
        },
        "required" : [ "like" ]
      } ]
    },
    "_types.query_dsl.ParentIdQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "id" : {
            "description" : "ID of the parent document.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Id"
            } ]
          },
          "ignore_unmapped" : {
            "description" : "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
            "default" : false,
            "type" : "boolean"
          },
          "type" : {
            "description" : "Name of the child relationship mapped for the `join` field.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.RelationName"
            } ]
          }
        }
      } ]
    },
    "_types.query_dsl.WildcardQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "case_insensitive" : {
            "description" : "Since Elasticsearch 7.10.0\nAllows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
            "x-state" : "Generally available; Added in 7.10.0",
            "type" : "boolean"
          },
          "rewrite" : {
            "description" : "Method used to rewrite the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "value" : {
            "description" : "Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.",
            "type" : "string"
          },
          "wildcard" : {
            "description" : "Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.",
            "type" : "string"
          }
        }
      } ]
    },
    "_types.Fields" : {
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.Field"
      }, {
        "type" : "array",
        "items" : {
          "$ref" : "#/definitions/_types.Field"
        }
      } ]
    },
    "_types.mapping.PercolatorProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "percolator" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.FailureStoreLifecycleTemplate" : {
      "description" : "Template equivalent of FailureStoreLifecycle that allows nullable values.",
      "type" : "object",
      "properties" : {
        "data_retention" : {
          "description" : "If defined, every document added to this data stream will be stored at least for this time frame.\nAny time after this duration the document could be deleted.\nWhen empty, every document in this data stream will be stored indefinitely.",
          "oneOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          }, {
            "nullable" : true,
            "type" : "string"
          } ]
        },
        "enabled" : {
          "description" : "If defined, it turns data stream lifecycle on/off (`true`/`false`) for this data stream. A data stream lifecycle\nthat's disabled (enabled: `false`) will have no effect on the data stream.",
          "default" : true,
          "type" : "boolean"
        }
      }
    },
    "_types.query_dsl.RegexpQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "case_insensitive" : {
            "description" : "Since Elasticsearch 7.10.0\nAllows case insensitive matching of the regular expression value with the indexed field values when set to `true`.\nWhen `false`, case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
            "default" : false,
            "x-state" : "Generally available; Added in 7.10.0",
            "type" : "boolean"
          },
          "flags" : {
            "description" : "Enables optional operators for the regular expression.",
            "type" : "string"
          },
          "max_determinized_states" : {
            "description" : "Maximum number of automaton states required for the query.",
            "default" : 10000.0,
            "type" : "number"
          },
          "rewrite" : {
            "description" : "Method used to rewrite the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "value" : {
            "description" : "Regular expression for terms you wish to find in the provided field.",
            "type" : "string"
          }
        },
        "required" : [ "value" ]
      } ]
    },
    "_types.query_dsl.TermQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "value" : {
            "description" : "Term you wish to find in the provided field.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.FieldValue"
            } ]
          },
          "case_insensitive" : {
            "description" : "Since Elasticsearch 7.10.0\nAllows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nWhen `false`, the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
            "default" : false,
            "x-state" : "Generally available; Added in 7.10.0",
            "type" : "boolean"
          }
        },
        "required" : [ "value" ]
      } ]
    },
    "_types.mapping.NestedProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.CorePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "enabled" : {
            "type" : "boolean"
          },
          "include_in_parent" : {
            "type" : "boolean"
          },
          "include_in_root" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "nested" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.ConstantScoreQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "filter" : {
            "description" : "Filter query you wish to run. Any returned documents must match this query.\nFilter queries do not calculate relevance scores.\nTo speed up performance, Elasticsearch automatically caches frequently used filter queries.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          }
        },
        "required" : [ "filter" ]
      } ]
    },
    "_types.query_dsl.PinnedQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "externalDocs" : {
          "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-pinned-query.html"
        },
        "allOf" : [ {
          "type" : "object",
          "properties" : {
            "organic" : {
              "description" : "Any choice of query used to rank documents which will be ranked below the \"pinned\" documents.",
              "allOf" : [ {
                "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
              } ]
            }
          },
          "required" : [ "organic" ]
        }, {
          "type" : "object",
          "properties" : {
            "ids" : {
              "description" : "Document IDs listed in the order they are to appear in results.\nRequired if `docs` is not specified.",
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.Id"
              }
            },
            "docs" : {
              "description" : "Documents listed in the order they are to appear in results.\nRequired if `ids` is not specified.",
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.query_dsl.PinnedDoc"
              }
            }
          },
          "minProperties" : 1,
          "maxProperties" : 1
        } ]
      } ]
    },
    "_types.mapping.PointProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "ignore_z_value" : {
            "type" : "boolean"
          },
          "null_value" : {
            "type" : "string"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "point" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.SettingsSimilarityBm25" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "BM25" ]
        },
        "b" : {
          "type" : "number"
        },
        "discount_overlaps" : {
          "type" : "boolean"
        },
        "k1" : {
          "type" : "number"
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.PercolateQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "document" : {
            "description" : "The source of the document being percolated.",
            "type" : "object"
          },
          "documents" : {
            "description" : "An array of sources of the documents being percolated.",
            "type" : "array",
            "items" : {
              "type" : "object"
            }
          },
          "field" : {
            "description" : "Field that holds the indexed queries. The field must use the `percolator` mapping type.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "id" : {
            "description" : "The ID of a stored document to percolate.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Id"
            } ]
          },
          "index" : {
            "description" : "The index of a stored document to percolate.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.IndexName"
            } ]
          },
          "name" : {
            "description" : "The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified.",
            "type" : "string"
          },
          "preference" : {
            "description" : "Preference used to fetch document to percolate.",
            "type" : "string"
          },
          "routing" : {
            "description" : "Routing used to fetch document to percolate.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Routing"
            } ]
          },
          "version" : {
            "description" : "The expected version of a stored document to percolate.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.VersionNumber"
            } ]
          }
        },
        "required" : [ "field" ]
      } ]
    },
    "_types.query_dsl.WeightedTokensQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "tokens" : {
            "description" : "The tokens representing this query",
            "type" : "object",
            "additionalProperties" : {
              "type" : "number"
            }
          },
          "pruning_config" : {
            "description" : "Token pruning configurations",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.TokenPruningConfig"
            } ]
          }
        },
        "required" : [ "tokens" ]
      } ]
    },
    "_types.mapping.ShapeProperty" : {
      "description" : "The `shape` data type facilitates the indexing of and searching with arbitrary `x, y` cartesian shapes such as\nrectangles and polygons.",
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "coerce" : {
            "type" : "boolean"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "ignore_z_value" : {
            "type" : "boolean"
          },
          "orientation" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.GeoOrientation"
            } ]
          },
          "type" : {
            "type" : "string",
            "enum" : [ "shape" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.IndexRoutingAllocation" : {
      "type" : "object",
      "properties" : {
        "enable" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRoutingAllocationOptions"
          } ]
        },
        "include" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRoutingAllocationInclude"
          } ]
        },
        "initial_recovery" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRoutingAllocationInitialRecovery"
          } ]
        },
        "disk" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.IndexRoutingAllocationDisk"
          } ]
        }
      }
    },
    "_types.mapping.WildcardProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "wildcard" ]
          },
          "null_value" : {
            "x-state" : "Generally available; Added in 7.15.0",
            "type" : "string",
            "description" : "Since Elasticsearch 7.15.0"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.RankFeaturesProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "positive_score_impact" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "rank_features" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.CharFilter" : {
      "externalDocs" : {
        "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/analysis-charfilters.html"
      },
      "oneOf" : [ {
        "type" : "string"
      }, {
        "$ref" : "#/definitions/_types.analysis.CharFilterDefinition"
      } ],
      "defaultSnippets" : [ {
        "label" : "add new char filter",
        "body" : {
          "type" : "$1"
        }
      } ]
    },
    "_types.mapping.DateProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number"
          },
          "fielddata" : {
            "allOf" : [ {
              "$ref" : "#/definitions/indices._types.NumericFielddata"
            } ]
          },
          "format" : {
            "type" : "string"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "null_value" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateTime"
            } ]
          },
          "precision_step" : {
            "type" : "number"
          },
          "locale" : {
            "type" : "string"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "date" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.Murmur3HashProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "murmur3" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.ByteSize" : {
      "oneOf" : [ {
        "type" : "number"
      }, {
        "type" : "string"
      } ],
      "description" : "A size in bytes. Units can be `gb` (gigabytes), `mb` (megabytes), `kb` (kilobytes)."
    },
    "_types.mapping.LongNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "long" ]
          },
          "null_value" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.Normalizer" : {
      "discriminator" : {
        "propertyName" : "type",
        "mapping" : {
          "custom" : "#/components/schemas/_types.analysis.CustomNormalizer",
          "lowercase" : "#/components/schemas/_types.analysis.LowercaseNormalizer"
        }
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.analysis.LowercaseNormalizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.CustomNormalizer"
      } ],
      "defaultSnippets" : [ {
        "label" : "add new normalizer",
        "body" : {
          "type" : "$1"
        }
      } ]
    },
    "_types.query_dsl.SpanNearQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "clauses" : {
            "description" : "Array of one or more other span type queries.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            }
          },
          "in_order" : {
            "description" : "Controls whether matches are required to be in-order.",
            "type" : "boolean"
          },
          "slop" : {
            "description" : "Controls the maximum number of intervening unmatched positions permitted.",
            "type" : "number"
          }
        },
        "required" : [ "clauses" ]
      } ]
    },
    "_types.query_dsl.MatchAllQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object"
      } ]
    },
    "_types.query_dsl.GeoDistanceQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "distance" : {
            "description" : "The radius of the circle centred on the specified location.\nPoints which fall into this circle are considered to be matches.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Distance"
            } ]
          },
          "distance_type" : {
            "description" : "How to compute the distance.\nSet to `plane` for a faster calculation that's inaccurate on long distances and close to the poles.",
            "default" : "'arc'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.GeoDistanceType"
            } ]
          },
          "validation_method" : {
            "description" : "Set to `IGNORE_MALFORMED` to accept geo points with invalid latitude or longitude.\nSet to `COERCE` to also try to infer correct latitude or longitude.",
            "default" : "'strict'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.GeoValidationMethod"
            } ]
          },
          "ignore_unmapped" : {
            "description" : "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
            "default" : false,
            "type" : "boolean"
          }
        },
        "required" : [ "distance" ]
      } ]
    },
    "_types.query_dsl.ShapeQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_unmapped" : {
            "description" : "When set to `true` the query ignores an unmapped field and will not match any documents.",
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.query_dsl.RangeQuery" : {
      "externalDocs" : {
        "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/query-dsl-range-query.html"
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.UntypedRangeQuery"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.DateRangeQuery"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.NumberRangeQuery"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.TermRangeQuery"
      } ]
    },
    "indices._types.SettingsSimilarityIb" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "IB" ]
        },
        "distribution" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.IBDistribution"
          } ]
        },
        "lambda" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.IBLambda"
          } ]
        },
        "normalization" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Normalization"
          } ]
        }
      },
      "required" : [ "type", "distribution", "lambda", "normalization" ]
    },
    "_types.query_dsl.BoostingQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "negative_boost" : {
            "description" : "Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.",
            "type" : "number"
          },
          "negative" : {
            "description" : "Query used to decrease the relevance score of matching documents.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "positive" : {
            "description" : "Any returned documents must match this query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          }
        },
        "required" : [ "negative_boost", "negative", "positive" ]
      } ]
    },
    "_types.mapping.ConstantKeywordProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "value" : {
            "type" : "object"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "constant_keyword" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.GeoPolygonQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "validation_method" : {
            "default" : "'strict'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.GeoValidationMethod"
            } ]
          },
          "ignore_unmapped" : {
            "type" : "boolean"
          }
        }
      } ]
    },
    "indices._types.MergeScheduler" : {
      "type" : "object",
      "properties" : {
        "max_thread_count" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
          } ]
        },
        "max_merge_count" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
          } ]
        }
      }
    },
    "_types.mapping.IpProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number"
          },
          "index" : {
            "type" : "boolean"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "null_value" : {
            "type" : "string"
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "time_series_dimension" : {
            "description" : "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
            "x-state" : "Technical preview",
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "ip" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.MappingLimitSettingsNestedObjects" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "description" : "The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps\nto prevent out of memory errors when a document contains too many nested objects.",
          "default" : 10000.0,
          "type" : "number"
        }
      }
    },
    "_types.mapping.DynamicProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "{dynamic_type}" ]
          },
          "enabled" : {
            "type" : "boolean"
          },
          "null_value" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.FieldValue"
            } ]
          },
          "boost" : {
            "type" : "number"
          },
          "coerce" : {
            "type" : "boolean"
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "time_series_metric" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TimeSeriesMetricType"
            } ]
          },
          "analyzer" : {
            "type" : "string"
          },
          "eager_global_ordinals" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          },
          "index_options" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.IndexOptions"
            } ]
          },
          "index_phrases" : {
            "type" : "boolean"
          },
          "index_prefixes" : {
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TextIndexPrefixes"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          },
          "norms" : {
            "type" : "boolean"
          },
          "position_increment_gap" : {
            "type" : "number"
          },
          "search_analyzer" : {
            "type" : "string"
          },
          "search_quote_analyzer" : {
            "type" : "string"
          },
          "term_vector" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TermVectorOption"
            } ]
          },
          "format" : {
            "type" : "string"
          },
          "precision_step" : {
            "type" : "number"
          },
          "locale" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.DenseVectorProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "dense_vector" ]
          },
          "dims" : {
            "description" : "Number of vector dimensions. Can't exceed `4096`. If `dims` is not specified, it will be set to the length of\nthe first vector added to the field.",
            "type" : "number"
          },
          "element_type" : {
            "description" : "The data type used to encode vectors. The supported data types are `float` (default), `byte`, and `bit`.",
            "default" : "float",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.DenseVectorElementType"
            } ]
          },
          "index" : {
            "description" : "If `true`, you can search this field using the kNN search API.",
            "default" : true,
            "type" : "boolean"
          },
          "index_options" : {
            "description" : "An optional section that configures the kNN indexing algorithm. The HNSW algorithm has two internal parameters\nthat influence how the data structure is built. These can be adjusted to improve the accuracy of results, at the\nexpense of slower indexing speed.\n\nThis parameter can only be specified when `index` is `true`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.DenseVectorIndexOptions"
            } ]
          },
          "similarity" : {
            "description" : "The vector similarity metric to use in kNN search.\n\nDocuments are ranked by their vector field's similarity to the query vector. The `_score` of each document will\nbe derived from the similarity, in a way that ensures scores are positive and that a larger score corresponds\nto a higher ranking.\n\nDefaults to `l2_norm` when `element_type` is `bit` otherwise defaults to `cosine`.\n\n`bit` vectors only support `l2_norm` as their similarity metric.\n\nThis parameter can only be specified when `index` is `true`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.DenseVectorSimilarity"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.MappingLimitSettingsSourceFields" : {
      "type" : "object",
      "properties" : {
        "mode" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SourceMode"
          } ]
        }
      },
      "required" : [ "mode" ]
    },
    "_types.mapping.PassthroughObjectProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.CorePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "passthrough" ]
          },
          "enabled" : {
            "type" : "boolean"
          },
          "priority" : {
            "type" : "number"
          },
          "time_series_dimension" : {
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.query_dsl.FunctionScoreQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost_mode" : {
            "description" : "Defines how he newly computed score is combined with the score of the query",
            "default" : "multiply",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.FunctionBoostMode"
            } ]
          },
          "functions" : {
            "description" : "One or more functions that compute a new score for each document returned by the query.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.query_dsl.FunctionScoreContainer"
            }
          },
          "max_boost" : {
            "description" : "Restricts the new score to not exceed the provided limit.",
            "type" : "number"
          },
          "min_score" : {
            "description" : "Excludes documents that do not meet the provided score threshold.",
            "type" : "number"
          },
          "query" : {
            "description" : "A query that determines the documents for which a new score is computed.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "score_mode" : {
            "description" : "Specifies how the computed scores are combined",
            "default" : "multiply",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.FunctionScoreMode"
            } ]
          }
        }
      } ]
    },
    "indices._types.StorageType" : {
      "anyOf" : [ {
        "type" : "string",
        "enum" : [ "fs", "niofs", "mmapfs", "hybridfs" ]
      }, {
        "type" : "string"
      } ]
    },
    "_types.query_dsl.SpanFieldMaskingQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "field" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          },
          "query" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          }
        },
        "required" : [ "field", "query" ]
      } ]
    },
    "_types.query_dsl.HasParentQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_unmapped" : {
            "description" : "Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error.\nYou can use this parameter to query multiple indices that may not contain the `parent_type`.",
            "default" : false,
            "type" : "boolean"
          },
          "inner_hits" : {
            "description" : "If defined, each search hit will contain inner hits.",
            "allOf" : [ {
              "$ref" : "#/definitions/_global.search._types.InnerHits"
            } ]
          },
          "parent_type" : {
            "description" : "Name of the parent relationship mapped for the `join` field.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.RelationName"
            } ]
          },
          "query" : {
            "description" : "Query you wish to run on parent documents of the `parent_type` field.\nIf a parent document matches the search, the query returns its child documents.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "score" : {
            "description" : "Indicates whether the relevance score of a matching parent document is aggregated into its child documents.",
            "default" : false,
            "type" : "boolean"
          }
        },
        "required" : [ "parent_type", "query" ]
      } ]
    },
    "_types.query_dsl.ScriptScoreQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "min_score" : {
            "description" : "Documents with a score lower than this floating point number are excluded from the search results.",
            "type" : "number"
          },
          "query" : {
            "description" : "Query used to return documents.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "script" : {
            "description" : "Script used to compute the score of documents returned by the query.\nImportant: final relevance scores from the `script_score` query cannot be negative.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          }
        },
        "required" : [ "query", "script" ]
      } ]
    },
    "_types.query_dsl.SpanOrQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "clauses" : {
            "description" : "Array of one or more other span type queries.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            }
          }
        },
        "required" : [ "clauses" ]
      } ]
    },
    "_types.mapping.ByteNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "byte" ]
          },
          "null_value" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.byte"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.TokenCountProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "type" : "string"
          },
          "boost" : {
            "type" : "number"
          },
          "index" : {
            "type" : "boolean"
          },
          "null_value" : {
            "type" : "number"
          },
          "enable_position_increments" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "token_count" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.MappingLimitSettingsFieldNameLength" : {
      "type" : "object",
      "properties" : {
        "limit" : {
          "description" : "Setting for the maximum length of a field name. This setting isnâ€™t really something that addresses mappings explosion but\nmight still be useful if you want to limit the field length. It usually shouldnâ€™t be necessary to set this setting. The\ndefault is okay unless a user starts to add a huge number of fields with really long names. Default is `Long.MAX_VALUE` (no limit).",
          "type" : "number"
        }
      }
    },
    "_types.mapping.IpRangeProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.RangePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "ip_range" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.SettingsSimilarityLmj" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "LMJelinekMercer" ]
        },
        "lambda" : {
          "type" : "number"
        }
      },
      "required" : [ "type" ]
    },
    "indices._types.TranslogDurability" : {
      "type" : "string",
      "enum" : [ "request", "REQUEST", "async", "ASYNC" ]
    },
    "indices._types.SettingsSimilarityLmd" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "LMDirichlet" ]
        },
        "mu" : {
          "type" : "number"
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.IntegerRangeProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.RangePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "integer_range" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.GeoShapeProperty" : {
      "description" : "The `geo_shape` data type facilitates the indexing of and searching with arbitrary geo shapes such as rectangles\nand polygons.",
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "coerce" : {
            "type" : "boolean"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "ignore_z_value" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          },
          "orientation" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.GeoOrientation"
            } ]
          },
          "strategy" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.GeoStrategy"
            } ]
          },
          "type" : {
            "type" : "string",
            "enum" : [ "geo_shape" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.DoubleNumberProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.NumberPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "double" ]
          },
          "null_value" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.MatchPhrasePrefixQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "description" : "Analyzer used to convert text in the query value into tokens.",
            "type" : "string"
          },
          "max_expansions" : {
            "description" : "Maximum number of terms to which the last provided term of the query value will expand.",
            "default" : 50.0,
            "type" : "number"
          },
          "query" : {
            "description" : "Text you wish to find in the provided field.",
            "type" : "string"
          },
          "slop" : {
            "description" : "Maximum number of positions allowed between matching tokens.",
            "default" : 0.0,
            "type" : "number"
          },
          "zero_terms_query" : {
            "description" : "Indicates whether no documents are returned if the analyzer removes all tokens, such as when using a `stop` filter.",
            "default" : "none",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.ZeroTermsQuery"
            } ]
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.mapping.FlattenedProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number"
          },
          "depth_limit" : {
            "type" : "number"
          },
          "doc_values" : {
            "type" : "boolean"
          },
          "eager_global_ordinals" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          },
          "index_options" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.IndexOptions"
            } ]
          },
          "null_value" : {
            "type" : "string"
          },
          "similarity" : {
            "type" : "string"
          },
          "split_queries_on_whitespace" : {
            "type" : "boolean"
          },
          "time_series_dimensions" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "type" : {
            "type" : "string",
            "enum" : [ "flattened" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.MultiMatchQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "description" : "Analyzer used to convert the text in the query value into tokens.",
            "type" : "string"
          },
          "auto_generate_synonyms_phrase_query" : {
            "description" : "If `true`, match phrase queries are automatically created for multi-term synonyms.",
            "default" : true,
            "type" : "boolean"
          },
          "cutoff_frequency" : {
            "deprecated" : true,
            "type" : "number"
          },
          "fields" : {
            "description" : "The fields to be queried.\nDefaults to the `index.query.default_field` index settings, which in turn defaults to `*`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fields"
            } ]
          },
          "fuzziness" : {
            "description" : "Maximum edit distance allowed for matching.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fuzziness"
            } ]
          },
          "fuzzy_rewrite" : {
            "description" : "Method used to rewrite the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "fuzzy_transpositions" : {
            "description" : "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
            "default" : true,
            "type" : "boolean"
          },
          "lenient" : {
            "description" : "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
            "default" : false,
            "type" : "boolean"
          },
          "max_expansions" : {
            "description" : "Maximum number of terms to which the query will expand.",
            "default" : 50.0,
            "type" : "number"
          },
          "minimum_should_match" : {
            "description" : "Minimum number of clauses that must match for a document to be returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "operator" : {
            "description" : "Boolean logic used to interpret text in the query value.",
            "default" : "'or'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Operator"
            } ]
          },
          "prefix_length" : {
            "description" : "Number of beginning characters left unchanged for fuzzy matching.",
            "default" : 0.0,
            "type" : "number"
          },
          "query" : {
            "description" : "Text, number, boolean value or date you wish to find in the provided field.",
            "type" : "string"
          },
          "slop" : {
            "description" : "Maximum number of positions allowed between matching tokens.",
            "default" : 0.0,
            "type" : "number"
          },
          "tie_breaker" : {
            "description" : "Determines how scores for each per-term blended query and scores across groups are combined.",
            "default" : 0.0,
            "type" : "number"
          },
          "type" : {
            "description" : "How `the` multi_match query is executed internally.",
            "default" : "'best_fields'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.TextQueryType"
            } ]
          },
          "zero_terms_query" : {
            "description" : "Indicates whether no documents are returned if the `analyzer` removes all tokens, such as when using a `stop` filter.",
            "default" : "'none'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.ZeroTermsQuery"
            } ]
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.query_dsl.SimpleQueryStringQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "description" : "Analyzer used to convert text in the query string into tokens.",
            "type" : "string"
          },
          "analyze_wildcard" : {
            "description" : "If `true`, the query attempts to analyze wildcard terms in the query string.",
            "default" : false,
            "type" : "boolean"
          },
          "auto_generate_synonyms_phrase_query" : {
            "description" : "If `true`, the parser creates a match_phrase query for each multi-position token.",
            "default" : true,
            "type" : "boolean"
          },
          "default_operator" : {
            "description" : "Default boolean logic used to interpret text in the query string if no operators are specified.",
            "default" : "'or'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Operator"
            } ]
          },
          "fields" : {
            "description" : "Array of fields you wish to search.\nAccepts wildcard expressions.\nYou also can boost relevance scores for matches to particular fields using a caret (`^`) notation.\nDefaults to the `index.query.default_field index` setting, which has a default value of `*`.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.Field"
            }
          },
          "flags" : {
            "description" : "List of enabled operators for the simple query string syntax.",
            "default" : "ALL",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SimpleQueryStringFlags"
            } ]
          },
          "fuzzy_max_expansions" : {
            "description" : "Maximum number of terms to which the query expands for fuzzy matching.",
            "default" : 50.0,
            "type" : "number"
          },
          "fuzzy_prefix_length" : {
            "description" : "Number of beginning characters left unchanged for fuzzy matching.",
            "default" : 0.0,
            "type" : "number"
          },
          "fuzzy_transpositions" : {
            "description" : "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
            "type" : "boolean"
          },
          "lenient" : {
            "description" : "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
            "default" : false,
            "type" : "boolean"
          },
          "minimum_should_match" : {
            "description" : "Minimum number of clauses that must match for a document to be returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "query" : {
            "description" : "Query string in the simple query string syntax you wish to parse and use for search.",
            "type" : "string"
          },
          "quote_field_suffix" : {
            "description" : "Suffix appended to quoted text in the query string.",
            "type" : "string"
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.analysis.Tokenizer" : {
      "externalDocs" : {
        "url" : "https://www.elastic.co/guide/en/elasticsearch/reference/8.19/analysis-tokenizers.html"
      },
      "oneOf" : [ {
        "type" : "string"
      }, {
        "$ref" : "#/definitions/_types.analysis.TokenizerDefinition"
      } ]
    },
    "_types.mapping.BooleanProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number"
          },
          "fielddata" : {
            "allOf" : [ {
              "$ref" : "#/definitions/indices._types.NumericFielddata"
            } ]
          },
          "index" : {
            "type" : "boolean"
          },
          "null_value" : {
            "type" : "boolean"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "time_series_dimension" : {
            "description" : "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
            "x-state" : "Technical preview",
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "boolean" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.MatchBoolPrefixQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "description" : "Analyzer used to convert the text in the query value into tokens.",
            "type" : "string"
          },
          "fuzziness" : {
            "description" : "Maximum edit distance allowed for matching.\nCan be applied to the term subqueries constructed for all terms but the final term.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fuzziness"
            } ]
          },
          "fuzzy_rewrite" : {
            "description" : "Method used to rewrite the query.\nCan be applied to the term subqueries constructed for all terms but the final term.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "fuzzy_transpositions" : {
            "description" : "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
            "default" : true,
            "type" : "boolean"
          },
          "max_expansions" : {
            "description" : "Maximum number of terms to which the query will expand.\nCan be applied to the term subqueries constructed for all terms but the final term.",
            "default" : 50.0,
            "type" : "number"
          },
          "minimum_should_match" : {
            "description" : "Minimum number of clauses that must match for a document to be returned.\nApplied to the constructed bool query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "operator" : {
            "description" : "Boolean logic used to interpret text in the query value.\nApplied to the constructed bool query.",
            "default" : "'or'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Operator"
            } ]
          },
          "prefix_length" : {
            "description" : "Number of beginning characters left unchanged for fuzzy matching.\nCan be applied to the term subqueries constructed for all terms but the final term.",
            "default" : 0.0,
            "type" : "number"
          },
          "query" : {
            "description" : "Terms you wish to find in the provided field.\nThe last term is used in a prefix query.",
            "type" : "string"
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.query_dsl.HasChildQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_unmapped" : {
            "description" : "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
            "default" : false,
            "type" : "boolean"
          },
          "inner_hits" : {
            "description" : "If defined, each search hit will contain inner hits.",
            "allOf" : [ {
              "$ref" : "#/definitions/_global.search._types.InnerHits"
            } ]
          },
          "max_children" : {
            "description" : "Maximum number of child documents that match the query allowed for a returned parent document.\nIf the parent document exceeds this limit, it is excluded from the search results.",
            "type" : "number"
          },
          "min_children" : {
            "description" : "Minimum number of child documents that match the query required to match the query for a returned parent document.\nIf the parent document does not meet this limit, it is excluded from the search results.",
            "type" : "number"
          },
          "query" : {
            "description" : "Query you wish to run on child documents of the `type` field.\nIf a child document matches the search, the query returns the parent document.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "score_mode" : {
            "description" : "Indicates how scores for matching child documents affect the root parent documentâ€™s relevance score.",
            "default" : "'none'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.ChildScoreMode"
            } ]
          },
          "type" : {
            "description" : "Name of the child relationship mapped for the `join` field.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.RelationName"
            } ]
          }
        },
        "required" : [ "query", "type" ]
      } ]
    },
    "_types.query_dsl.MatchQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "analyzer" : {
            "description" : "Analyzer used to convert the text in the query value into tokens.",
            "type" : "string"
          },
          "auto_generate_synonyms_phrase_query" : {
            "description" : "If `true`, match phrase queries are automatically created for multi-term synonyms.",
            "default" : true,
            "type" : "boolean"
          },
          "cutoff_frequency" : {
            "deprecated" : true,
            "type" : "number"
          },
          "fuzziness" : {
            "description" : "Maximum edit distance allowed for matching.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fuzziness"
            } ]
          },
          "fuzzy_rewrite" : {
            "description" : "Method used to rewrite the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "fuzzy_transpositions" : {
            "description" : "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
            "default" : true,
            "type" : "boolean"
          },
          "lenient" : {
            "description" : "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
            "default" : false,
            "type" : "boolean"
          },
          "max_expansions" : {
            "description" : "Maximum number of terms to which the query will expand.",
            "default" : 50.0,
            "type" : "number"
          },
          "minimum_should_match" : {
            "description" : "Minimum number of clauses that must match for a document to be returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MinimumShouldMatch"
            } ]
          },
          "operator" : {
            "description" : "Boolean logic used to interpret text in the query value.",
            "default" : "'or'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.Operator"
            } ]
          },
          "prefix_length" : {
            "description" : "Number of beginning characters left unchanged for fuzzy matching.",
            "default" : 0.0,
            "type" : "number"
          },
          "query" : {
            "description" : "Text, number, boolean value or date you wish to find in the provided field.",
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "number"
            }, {
              "type" : "boolean"
            } ]
          },
          "zero_terms_query" : {
            "description" : "Indicates whether no documents are returned if the `analyzer` removes all tokens, such as when using a `stop` filter.",
            "default" : "'none'",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.ZeroTermsQuery"
            } ]
          }
        },
        "required" : [ "query" ]
      } ]
    },
    "_types.query_dsl.PrefixQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "rewrite" : {
            "description" : "Method used to rewrite the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.MultiTermQueryRewrite"
            } ]
          },
          "value" : {
            "description" : "Beginning characters of terms you wish to find in the provided field.",
            "type" : "string"
          },
          "case_insensitive" : {
            "description" : "Since Elasticsearch 7.10.0\nAllows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nDefault is `false` which means the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
            "default" : false,
            "x-state" : "Generally available; Added in 7.10.0",
            "type" : "boolean"
          }
        },
        "required" : [ "value" ]
      } ]
    },
    "_types.mapping.VersionProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "version" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.GeoShapeQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "ignore_unmapped" : {
            "description" : "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
            "default" : false,
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.query_dsl.SpanNotQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "dist" : {
            "description" : "The number of tokens from within the include span that canâ€™t have overlap with the exclude span.\nEquivalent to setting both `pre` and `post`.",
            "type" : "number"
          },
          "exclude" : {
            "description" : "Span query whose matches must not overlap those returned.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          },
          "include" : {
            "description" : "Span query whose matches are filtered.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.SpanQuery"
            } ]
          },
          "post" : {
            "description" : "The number of tokens after the include span that canâ€™t have overlap with the exclude span.",
            "default" : 0.0,
            "type" : "number"
          },
          "pre" : {
            "description" : "The number of tokens before the include span that canâ€™t have overlap with the exclude span.",
            "default" : 0.0,
            "type" : "number"
          }
        },
        "required" : [ "exclude", "include" ]
      } ]
    },
    "_types.mapping.SparseVectorProperty" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "store" : {
            "type" : "boolean"
          },
          "type" : {
            "type" : "string",
            "enum" : [ "sparse_vector" ]
          },
          "index_options" : {
            "description" : "Since Elasticsearch 8.19.0\nAdditional index options for the sparse vector field that controls the\ntoken pruning behavior of the sparse vector field.",
            "x-state" : "Generally available; Added in 8.19.0",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.SparseVectorIndexOptions"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.SettingsSimilarityDfr" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "DFR" ]
        },
        "after_effect" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DFRAfterEffect"
          } ]
        },
        "basic_model" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DFRBasicModel"
          } ]
        },
        "normalization" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Normalization"
          } ]
        }
      },
      "required" : [ "type", "after_effect", "basic_model", "normalization" ]
    },
    "_types.Script" : {
      "type" : "object",
      "properties" : {
        "source" : {
          "description" : "The script source.",
          "type" : "string"
        },
        "id" : {
          "description" : "The `id` for a stored script.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Id"
          } ]
        },
        "params" : {
          "description" : "Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time.",
          "type" : "object",
          "additionalProperties" : {
            "type" : "object"
          }
        },
        "lang" : {
          "description" : "Specifies the language the script is written in.",
          "default" : "painless",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.ScriptLanguage"
          } ]
        },
        "options" : {
          "type" : "object",
          "additionalProperties" : {
            "type" : "string"
          }
        }
      }
    },
    "indices._types.SettingsSimilarityDfi" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "DFI" ]
        },
        "independence_measure" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DFIIndependenceMeasure"
          } ]
        }
      },
      "required" : [ "type", "independence_measure" ]
    },
    "indices._types.TranslogRetention" : {
      "type" : "object",
      "properties" : {
        "size" : {
          "description" : "This controls the total size of translog files to keep for each shard. Keeping more translog files increases\nthe chance of performing an operation based sync when recovering a replica. If the translog files are not\nsufficient, replica recovery will fall back to a file based sync. This setting is ignored, and should not be\nset, if soft deletes are enabled. Soft deletes are enabled by default in indices created in Elasticsearch\nversions 7.0.0 and later.",
          "default" : "512mb",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.ByteSize"
          } ]
        },
        "age" : {
          "description" : "This controls the maximum duration for which translog files are kept by each shard. Keeping more\ntranslog files increases the chance of performing an operation based sync when recovering replicas. If\nthe translog files are not sufficient, replica recovery will fall back to a file based sync. This setting\nis ignored, and should not be set, if soft deletes are enabled. Soft deletes are enabled by default in\nindices created in Elasticsearch versions 7.0.0 and later.",
          "default" : "12h",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ]
        }
      }
    },
    "_types.query_dsl.RankFeatureFunctionSigmoid" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunction"
      }, {
        "type" : "object",
        "properties" : {
          "pivot" : {
            "description" : "Configurable pivot value so that the result will be less than 0.5.",
            "type" : "number"
          },
          "exponent" : {
            "description" : "Configurable Exponent.",
            "type" : "number"
          }
        },
        "required" : [ "pivot", "exponent" ]
      } ]
    },
    "_types.GeoLocation" : {
      "description" : "A latitude/longitude as a 2 dimensional point. It can be represented in various ways:\n- as a `{lat, long}` object\n- as a geo hash value\n- as a `[lon, lat]` array\n- as a string in `\"<lat>, <lon>\"` or WKT point formats",
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.LatLonGeoLocation"
      }, {
        "$ref" : "#/definitions/_types.GeoHashLocation"
      }, {
        "type" : "array",
        "items" : {
          "type" : "number"
        }
      }, {
        "type" : "string"
      } ]
    },
    "_types.query_dsl.IntervalsFuzzy" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "description" : "Analyzer used to normalize the term.",
          "type" : "string"
        },
        "fuzziness" : {
          "description" : "Maximum edit distance allowed for matching.",
          "default" : "auto",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Fuzziness"
          } ]
        },
        "prefix_length" : {
          "description" : "Number of beginning characters left unchanged when creating expansions.",
          "default" : 0.0,
          "type" : "number"
        },
        "term" : {
          "description" : "The term to match.",
          "type" : "string"
        },
        "transpositions" : {
          "description" : "Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).",
          "default" : true,
          "type" : "boolean"
        },
        "use_field" : {
          "description" : "If specified, match intervals from this field rather than the top-level field.\nThe `term` is normalized using the search analyzer from this field, unless `analyzer` is specified separately.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        }
      },
      "required" : [ "term" ]
    },
    "_types.query_dsl.CombinedFieldsZeroTerms" : {
      "type" : "string",
      "enum" : [ "none", "all" ]
    },
    "_types.mapping.RangePropertyBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number"
          },
          "coerce" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.query_dsl.SimpleQueryStringFlags" : {
      "description" : "Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`",
      "allOf" : [ {
        "$ref" : "#/definitions/_spec_utils.PipeSeparatedFlagsSimpleQueryStringFlag"
      } ]
    },
    "_types.query_dsl.FunctionBoostMode" : {
      "type" : "string",
      "enum" : [ "multiply", "replace", "sum", "avg", "max", "min" ]
    },
    "_types.Ids" : {
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.Id"
      }, {
        "type" : "array",
        "items" : {
          "$ref" : "#/definitions/_types.Id"
        }
      } ]
    },
    "_types.TimeZone" : {
      "type" : "string"
    },
    "_types.query_dsl.UntypedRangeQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RangeQueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "description" : "Date format used to convert `date` values in the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateFormat"
            } ]
          },
          "time_zone" : {
            "description" : "Coordinated Universal Time (UTC) offset or IANA time zone used to convert `date` values in the query to UTC.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.TimeZone"
            } ]
          }
        }
      } ]
    },
    "_types.query_dsl.FunctionScoreMode" : {
      "type" : "string",
      "enum" : [ "multiply", "sum", "avg", "first", "max", "min" ]
    },
    "_types.Id" : {
      "type" : "string"
    },
    "_types.analysis.CzechAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "czech" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.ZeroTermsQuery" : {
      "type" : "string",
      "enum" : [ "all", "none" ]
    },
    "_types.mapping.DenseVectorElementType" : {
      "type" : "string",
      "enum" : [ "bit", "byte", "float" ]
    },
    "_types.query_dsl.FunctionScoreContainer" : {
      "allOf" : [ {
        "type" : "object",
        "properties" : {
          "filter" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
            } ]
          },
          "weight" : {
            "type" : "number"
          }
        }
      }, {
        "type" : "object",
        "properties" : {
          "exp" : {
            "description" : "Function that scores a document with a exponential decay, depending on the distance of a numeric field value of the document from an origin.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.DecayFunction"
            } ]
          },
          "gauss" : {
            "description" : "Function that scores a document with a normal decay, depending on the distance of a numeric field value of the document from an origin.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.DecayFunction"
            } ]
          },
          "linear" : {
            "description" : "Function that scores a document with a linear decay, depending on the distance of a numeric field value of the document from an origin.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.DecayFunction"
            } ]
          },
          "field_value_factor" : {
            "description" : "Function allows you to use a field from a document to influence the score.\nItâ€™s similar to using the script_score function, however, it avoids the overhead of scripting.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.FieldValueFactorScoreFunction"
            } ]
          },
          "random_score" : {
            "description" : "Generates scores that are uniformly distributed from 0 up to but not including 1.\nIn case you want scores to be reproducible, it is possible to provide a `seed` and `field`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RandomScoreFunction"
            } ]
          },
          "script_score" : {
            "description" : "Enables you to wrap another query and customize the scoring of it optionally with a computation derived from other numeric field values in the doc using a script expression.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.ScriptScoreFunction"
            } ]
          }
        },
        "minProperties" : 1,
        "maxProperties" : 1
      } ]
    },
    "_types.query_dsl.UntypedDistanceFeatureQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.DistanceFeatureQueryBase"
      }, {
        "type" : "object"
      } ]
    },
    "_types.analysis.LatvianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "latvian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.SoraniAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "sorani" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.DFRAfterEffect" : {
      "type" : "string",
      "enum" : [ "no", "b", "l" ]
    },
    "_types.DurationLarge" : {
      "description" : "A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and\n`y` (year)",
      "type" : "string"
    },
    "_types.mapping.NumberPropertyBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.DocValuesPropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "boost" : {
            "type" : "number"
          },
          "coerce" : {
            "type" : "boolean"
          },
          "ignore_malformed" : {
            "type" : "boolean"
          },
          "index" : {
            "type" : "boolean"
          },
          "on_script_error" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.OnScriptError"
            } ]
          },
          "script" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          },
          "time_series_metric" : {
            "description" : "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
            "x-state" : "Technical preview",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.mapping.TimeSeriesMetricType"
            } ]
          },
          "time_series_dimension" : {
            "description" : "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
            "default" : false,
            "x-state" : "Technical preview",
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.query_dsl.IntervalsAnyOf" : {
      "type" : "object",
      "properties" : {
        "intervals" : {
          "description" : "An array of rules to match.",
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          }
        },
        "filter" : {
          "description" : "Rule used to filter returned intervals.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsFilter"
          } ]
        }
      },
      "required" : [ "intervals" ]
    },
    "_types.analysis.ArabicAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "arabic" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.Distance" : {
      "type" : "string"
    },
    "_types.mapping.SuggestContext" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Name"
          } ]
        },
        "path" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "type" : {
          "type" : "string"
        },
        "precision" : {
          "oneOf" : [ {
            "type" : "number"
          }, {
            "type" : "string"
          } ]
        }
      },
      "required" : [ "name", "type" ]
    },
    "_types.query_dsl.ChildScoreMode" : {
      "type" : "string",
      "enum" : [ "none", "avg", "sum", "max", "min" ]
    },
    "_types.mapping.TermVectorOption" : {
      "type" : "string",
      "enum" : [ "no", "yes", "with_offsets", "with_positions", "with_positions_offsets", "with_positions_offsets_payloads", "with_positions_payloads" ]
    },
    "indices._types.IndexRoutingAllocationInitialRecovery" : {
      "type" : "object",
      "properties" : {
        "_id" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Id"
          } ]
        }
      }
    },
    "_types.analysis.PatternAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "pattern" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        },
        "flags" : {
          "type" : "string"
        },
        "lowercase" : {
          "type" : "boolean"
        },
        "pattern" : {
          "type" : "string"
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        }
      },
      "required" : [ "type", "pattern" ]
    },
    "_types.analysis.StopAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "stop" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.CustomNormalizer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "custom" ]
        },
        "char_filter" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "examples" : [ "html_strip" ]
          }
        },
        "filter" : {
          "type" : "array",
          "items" : {
            "type" : "string",
            "$ref" : "#/definitions/filter_examples"
          },
          "default" : [ ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.IBDistribution" : {
      "type" : "string",
      "enum" : [ "ll", "spl" ]
    },
    "_types.GeoDistanceType" : {
      "type" : "string",
      "enum" : [ "arc", "plane" ]
    },
    "_types.byte" : {
      "type" : "number"
    },
    "_types.query_dsl.QueryBase" : {
      "type" : "object",
      "properties" : {
        "boost" : {
          "description" : "Floating point number used to decrease or increase the relevance scores of the query.\nBoost values are relative to the default value of 1.0.\nA boost value between 0 and 1.0 decreases the relevance score.\nA value greater than 1.0 increases the relevance score.",
          "default" : 1.0,
          "type" : "number"
        },
        "_name" : {
          "type" : "string"
        }
      }
    },
    "_types.mapping.IndexOptions" : {
      "type" : "string",
      "enum" : [ "docs", "freqs", "positions", "offsets" ]
    },
    "_types.RescoreVector" : {
      "type" : "object",
      "properties" : {
        "oversample" : {
          "description" : "Applies the specified oversample factor to k on the approximate kNN search",
          "type" : "number"
        }
      },
      "required" : [ "oversample" ]
    },
    "_types.analysis.KeywordAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "keyword" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.GeoHash" : {
      "type" : "string"
    },
    "_types.analysis.IcuCollationDecomposition" : {
      "type" : "string",
      "enum" : [ "no", "identical" ]
    },
    "_types.QueryVector" : {
      "type" : "array",
      "items" : {
        "type" : "number"
      }
    },
    "_types.query_dsl.Like" : {
      "description" : "Text that we want similar documents for or a lookup to a document's field for the text.",
      "oneOf" : [ {
        "type" : "string"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.LikeDocument"
      } ]
    },
    "_types.mapping.DocValuesPropertyBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.CorePropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "doc_values" : {
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.analysis.TokenizerDefinition" : {
      "discriminator" : {
        "propertyName" : "type",
        "mapping" : {
          "char_group" : "#/components/schemas/_types.analysis.CharGroupTokenizer",
          "classic" : "#/components/schemas/_types.analysis.ClassicTokenizer",
          "edge_ngram" : "#/components/schemas/_types.analysis.EdgeNGramTokenizer",
          "icu_tokenizer" : "#/components/schemas/_types.analysis.IcuTokenizer",
          "keyword" : "#/components/schemas/_types.analysis.KeywordTokenizer",
          "kuromoji_tokenizer" : "#/components/schemas/_types.analysis.KuromojiTokenizer",
          "letter" : "#/components/schemas/_types.analysis.LetterTokenizer",
          "lowercase" : "#/components/schemas/_types.analysis.LowercaseTokenizer",
          "ngram" : "#/components/schemas/_types.analysis.NGramTokenizer",
          "nori_tokenizer" : "#/components/schemas/_types.analysis.NoriTokenizer",
          "path_hierarchy" : "#/components/schemas/_types.analysis.PathHierarchyTokenizer",
          "pattern" : "#/components/schemas/_types.analysis.PatternTokenizer",
          "simple_pattern" : "#/components/schemas/_types.analysis.SimplePatternTokenizer",
          "simple_pattern_split" : "#/components/schemas/_types.analysis.SimplePatternSplitTokenizer",
          "standard" : "#/components/schemas/_types.analysis.StandardTokenizer",
          "thai" : "#/components/schemas/_types.analysis.ThaiTokenizer",
          "uax_url_email" : "#/components/schemas/_types.analysis.UaxEmailUrlTokenizer",
          "whitespace" : "#/components/schemas/_types.analysis.WhitespaceTokenizer"
        }
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CharGroupTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.ClassicTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.EdgeNGramTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.KeywordTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.LetterTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.LowercaseTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.NGramTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.PathHierarchyTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.PatternTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SimplePatternTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.SimplePatternSplitTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.StandardTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.ThaiTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.UaxEmailUrlTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.WhitespaceTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.IcuTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.KuromojiTokenizer"
      }, {
        "$ref" : "#/definitions/_types.analysis.NoriTokenizer"
      } ],
      "defaultSnippets" : [ {
        "label" : "add new tokenizer",
        "body" : {
          "type" : "$1"
        }
      } ],
      "properties" : {
        "type" : {
          "type" : "string",
          "$ref" : "#/definitions/tokenizer_examples"
        }
      }
    },
    "_types.analysis.ChineseAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "chinese" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.BrazilianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "brazilian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.VersionType" : {
      "type" : "string",
      "enum" : [ "internal", "external", "external_gte" ]
    },
    "_types.query_dsl.TextQueryType" : {
      "type" : "string",
      "enum" : [ "best_fields", "most_fields", "cross_fields", "phrase", "phrase_prefix", "bool_prefix" ]
    },
    "_types.analysis.StandardAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "standard" ]
        },
        "max_token_length" : {
          "type" : "number"
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "indices._types.IndexRoutingAllocationOptions" : {
      "type" : "string",
      "enum" : [ "all", "primaries", "new_primaries", "none" ]
    },
    "_types.analysis.SpanishAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "spanish" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.GeoTile" : {
      "description" : "A map tile reference, represented as `{zoom}/{x}/{y}`",
      "type" : "string"
    },
    "_types.query_dsl.IntervalsRegexp" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "description" : "Analyzer used to analyze the `prefix`.",
          "type" : "string"
        },
        "pattern" : {
          "description" : "Regex pattern.",
          "type" : "string"
        },
        "use_field" : {
          "description" : "If specified, match intervals from this field rather than the top-level field.\nThe `prefix` is normalized using the search analyzer from this field, unless `analyzer` is specified separately.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        }
      },
      "required" : [ "pattern" ]
    },
    "_types.query_dsl.IntervalsWildcard" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "description" : "Analyzer used to analyze the `pattern`.\nDefaults to the top-level field's analyzer.",
          "type" : "string"
        },
        "pattern" : {
          "description" : "Wildcard pattern used to find matching terms.",
          "type" : "string"
        },
        "use_field" : {
          "description" : "If specified, match intervals from this field rather than the top-level field.\nThe `pattern` is normalized using the search analyzer from this field, unless `analyzer` is specified separately.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        }
      },
      "required" : [ "pattern" ]
    },
    "_types.analysis.IcuCollationCaseFirst" : {
      "type" : "string",
      "enum" : [ "lower", "upper" ]
    },
    "_types.analysis.WhitespaceAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "whitespace" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.RomanianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "romanian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.ulong" : {
      "type" : "number"
    },
    "_types.analysis.HungarianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "hungarian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.CorePropertyBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.mapping.PropertyBase"
      }, {
        "type" : "object",
        "properties" : {
          "copy_to" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fields"
            } ],
            "defaultSnippets" : [ {
              "label" : "set copy_to",
              "body" : [ "${1:another_field}" ]
            } ]
          },
          "store" : {
            "type" : "boolean",
            "default" : false
          }
        }
      } ]
    },
    "_types.analysis.GermanAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "german" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.ThaiAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "thai" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.DateRangeQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RangeQueryBaseDateMath"
      }, {
        "type" : "object",
        "properties" : {
          "format" : {
            "description" : "Date format used to convert `date` values in the query.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateFormat"
            } ]
          },
          "time_zone" : {
            "description" : "Coordinated Universal Time (UTC) offset or IANA time zone used to convert `date` values in the query to UTC.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.TimeZone"
            } ]
          }
        }
      } ]
    },
    "_types.analysis.SwedishAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "swedish" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.short" : {
      "type" : "number"
    },
    "_types.mapping.RankVectorElementType" : {
      "type" : "string",
      "enum" : [ "byte", "float", "bit" ]
    },
    "_types.query_dsl.TermRangeQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RangeQueryBasestring"
      }, {
        "type" : "object"
      } ]
    },
    "_types.query_dsl.IntervalsPrefix" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "description" : "Analyzer used to analyze the `prefix`.",
          "type" : "string"
        },
        "prefix" : {
          "description" : "Beginning characters of terms you wish to find in the top-level field.",
          "type" : "string"
        },
        "use_field" : {
          "description" : "If specified, match intervals from this field rather than the top-level field.\nThe `prefix` is normalized using the search analyzer from this field, unless `analyzer` is specified separately.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        }
      },
      "required" : [ "prefix" ]
    },
    "indices._types.IndexRoutingAllocationDisk" : {
      "type" : "object",
      "properties" : {
        "threshold_enabled" : {
          "oneOf" : [ {
            "type" : "boolean"
          }, {
            "type" : "string"
          } ]
        }
      }
    },
    "_types.analysis.FingerprintAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "fingerprint" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        },
        "max_output_size" : {
          "type" : "number"
        },
        "preserve_original" : {
          "type" : "boolean"
        },
        "separator" : {
          "type" : "string"
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type", "max_output_size", "preserve_original", "separator" ]
    },
    "_types.TokenPruningConfig" : {
      "type" : "object",
      "properties" : {
        "tokens_freq_ratio_threshold" : {
          "description" : "Tokens whose frequency is more than this threshold times the average frequency of all tokens in the specified field are considered outliers and pruned.",
          "default" : 5.0,
          "type" : "number"
        },
        "tokens_weight_threshold" : {
          "description" : "Tokens whose weight is less than this threshold are considered nonsignificant and pruned.",
          "default" : 0.4,
          "type" : "number"
        },
        "only_score_pruned_tokens" : {
          "description" : "Whether to only score pruned tokens, vs only scoring kept tokens.",
          "default" : false,
          "type" : "boolean"
        }
      }
    },
    "_types.analysis.NoriAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "nori" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        },
        "decompound_mode" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.NoriDecompoundMode"
          } ]
        },
        "stoptags" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        },
        "user_dictionary" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.SemanticTextIndexOptions" : {
      "type" : "object",
      "properties" : {
        "dense_vector" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.DenseVectorIndexOptions"
          } ]
        }
      }
    },
    "_types.analysis.ArmenianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "armenian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.GeoExecution" : {
      "type" : "string",
      "enum" : [ "memory", "indexed" ]
    },
    "_types.analysis.PersianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "persian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.ChunkingSettings" : {
      "type" : "object",
      "properties" : {
        "strategy" : {
          "description" : "The chunking strategy: `sentence` or `word`.",
          "default" : "sentence",
          "type" : "string"
        },
        "max_chunk_size" : {
          "description" : "The maximum size of a chunk in words.\nThis value cannot be higher than `300` or lower than `20` (for `sentence` strategy) or `10` (for `word` strategy).",
          "default" : 250.0,
          "type" : "number"
        },
        "overlap" : {
          "description" : "The number of overlapping words for chunks.\nIt is applicable only to a `word` chunking strategy.\nThis value cannot be higher than half the `max_chunk_size` value.",
          "default" : 100.0,
          "type" : "number"
        },
        "sentence_overlap" : {
          "description" : "The number of overlapping sentences for chunks.\nIt is applicable only for a `sentence` chunking strategy.\nIt can be either `1` or `0`.",
          "default" : 1.0,
          "type" : "number"
        }
      },
      "required" : [ "strategy", "max_chunk_size" ]
    },
    "_types.mapping.GeoOrientation" : {
      "type" : "string",
      "enum" : [ "right", "RIGHT", "counterclockwise", "ccw", "left", "LEFT", "clockwise", "cw" ]
    },
    "_types.Fuzziness" : {
      "oneOf" : [ {
        "type" : "string"
      }, {
        "type" : "number"
      } ]
    },
    "_types.analysis.NorwegianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "norwegian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.Operator" : {
      "type" : "string",
      "enum" : [ "and", "AND", "or", "OR" ]
    },
    "_types.FieldValue" : {
      "description" : "A field value.",
      "oneOf" : [ {
        "type" : "number"
      }, {
        "type" : "number"
      }, {
        "type" : "string"
      }, {
        "type" : "boolean"
      }, {
        "nullable" : true,
        "type" : "string"
      }, {
        "type" : "object"
      } ]
    },
    "_types.DFIIndependenceMeasure" : {
      "type" : "string",
      "enum" : [ "standardized", "saturated", "chisquared" ]
    },
    "_types.query_dsl.RankFeatureFunctionSaturation" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunction"
      }, {
        "type" : "object",
        "properties" : {
          "pivot" : {
            "description" : "Configurable pivot value so that the result will be less than 0.5.",
            "type" : "number"
          }
        }
      } ]
    },
    "_types.analysis.ItalianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "italian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "indices._types.SourceMode" : {
      "type" : "string",
      "enum" : [ "disabled", "stored", "synthetic" ]
    },
    "_types.mapping.TimeSeriesMetricType" : {
      "type" : "string",
      "enum" : [ "gauge", "counter", "summary", "histogram", "position" ]
    },
    "_types.analysis.DutchAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "dutch" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.FrenchAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "french" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.PropertyBase" : {
      "type" : "object",
      "properties" : {
        "meta" : {
          "description" : "Metadata about the field.",
          "type" : "object",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "properties" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.mapping.Property"
          },
          "defaultSnippets" : [ {
            "label" : "add new property",
            "body" : {
              "${1:property1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "ignore_above" : {
          "type" : "number",
          "examples" : [ 4096 ]
        },
        "dynamic" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.DynamicMapping"
          } ]
        },
        "fields" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.mapping.Property"
          },
          "defaultSnippets" : [ {
            "label" : "add new field",
            "body" : {
              "${1:field1}" : {
                "type" : "$2"
              }
            }
          } ]
        },
        "synthetic_source_keep" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.SyntheticSourceKeepEnum"
          } ],
          "description" : "Since Elasticsearch 8.16.0"
        }
      }
    },
    "_types.analysis.GreekAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "greek" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.GeoDistanceFeatureQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.DistanceFeatureQueryBaseGeoLocationDistance"
      }, {
        "type" : "object"
      } ]
    },
    "indices._types.SlowlogTresholdLevels" : {
      "type" : "object",
      "properties" : {
        "warn" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ],
          "default" : "-1"
        },
        "info" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ],
          "default" : "-1"
        },
        "debug" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ],
          "default" : "-1"
        },
        "trace" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Duration"
          } ],
          "default" : "-1"
        }
      }
    },
    "_types.analysis.BengaliAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "bengali" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "indices._types.FielddataFrequencyFilter" : {
      "type" : "object",
      "properties" : {
        "max" : {
          "type" : "number"
        },
        "min" : {
          "type" : "number"
        },
        "min_segment_size" : {
          "type" : "number"
        }
      },
      "required" : [ "max", "min", "min_segment_size" ]
    },
    "_types.DFRBasicModel" : {
      "type" : "string",
      "enum" : [ "be", "d", "g", "if", "in", "ine", "p" ]
    },
    "_types.analysis.RussianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "russian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.DanishAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "danish" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.IntervalsMatch" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "description" : "Analyzer used to analyze terms in the query.",
          "type" : "string"
        },
        "max_gaps" : {
          "description" : "Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches.",
          "default" : -1.0,
          "type" : "number"
        },
        "ordered" : {
          "description" : "If `true`, matching terms must appear in their specified order.",
          "default" : false,
          "type" : "boolean"
        },
        "query" : {
          "description" : "Text you wish to find in the provided field.",
          "type" : "string"
        },
        "use_field" : {
          "description" : "If specified, match intervals from this field rather than the top-level field.\nThe `term` is normalized using the search analyzer from this field, unless `analyzer` is specified separately.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "filter" : {
          "description" : "An optional interval filter.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsFilter"
          } ]
        }
      },
      "required" : [ "query" ]
    },
    "_types.analysis.CustomAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "custom" ]
        },
        "char_filter" : {
          "oneOf" : [ {
            "type" : "string"
          }, {
            "type" : "array",
            "items" : {
              "type" : "string",
              "examples" : [ "html_strip" ]
            }
          } ],
          "default" : [ ]
        },
        "filter" : {
          "oneOf" : [ {
            "type" : "string"
          }, {
            "type" : "array",
            "items" : {
              "type" : "string",
              "$ref" : "#/definitions/filter_examples"
            }
          } ],
          "default" : [ ]
        },
        "position_increment_gap" : {
          "type" : "number",
          "default" : 100
        },
        "position_offset_gap" : {
          "type" : "number",
          "default" : 100
        },
        "tokenizer" : {
          "type" : "string",
          "$ref" : "#/definitions/tokenizer_examples"
        }
      },
      "required" : [ "type", "tokenizer" ]
    },
    "indices._types.IndexRoutingRebalanceOptions" : {
      "type" : "string",
      "enum" : [ "all", "primaries", "replicas", "none" ]
    },
    "_types.analysis.LithuanianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "lithuanian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.GeoValidationMethod" : {
      "type" : "string",
      "enum" : [ "coerce", "ignore_malformed", "strict" ]
    },
    "_types.analysis.BasqueAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "basque" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.CombinedFieldsOperator" : {
      "type" : "string",
      "enum" : [ "or", "and" ]
    },
    "_types.query_dsl.PinnedDoc" : {
      "type" : "object",
      "properties" : {
        "_id" : {
          "description" : "The unique document ID.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Id"
          } ]
        },
        "_index" : {
          "description" : "The index that contains the document.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.IndexName"
          } ]
        }
      },
      "required" : [ "_id", "_index" ]
    },
    "_types.Normalization" : {
      "type" : "string",
      "enum" : [ "no", "h1", "h2", "h3", "z" ]
    },
    "_types.UnitMillis" : {
      "description" : "Time unit for milliseconds",
      "type" : "number"
    },
    "_types.analysis.SnowballAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "snowball" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        },
        "language" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.SnowballLanguage"
          } ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        }
      },
      "required" : [ "type", "language" ]
    },
    "indices._types.SlowlogTresholds" : {
      "type" : "object",
      "properties" : {
        "query" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SlowlogTresholdLevels"
          } ]
        },
        "fetch" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.SlowlogTresholdLevels"
          } ]
        }
      }
    },
    "_types.mapping.SparseVectorIndexOptions" : {
      "type" : "object",
      "properties" : {
        "prune" : {
          "description" : "Since Elasticsearch 8.19.0\nWhether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false",
          "x-state" : "Generally available; Added in 8.19.0",
          "type" : "boolean"
        },
        "pruning_config" : {
          "description" : "Since Elasticsearch 8.19.0\nOptional pruning configuration.\nIf enabled, this will omit non-significant tokens from the query in order to improve query performance.\nThis is only used if prune is set to true.\nIf prune is set to true but pruning_config is not specified, default values will be used.",
          "x-state" : "Generally available; Added in 8.19.0",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.TokenPruningConfig"
          } ]
        }
      }
    },
    "_types.analysis.PortugueseAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "portuguese" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.CatalanAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "catalan" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.IntervalsAllOf" : {
      "type" : "object",
      "properties" : {
        "intervals" : {
          "description" : "An array of rules to combine. All rules must produce a match in a document for the overall source to match.",
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          }
        },
        "max_gaps" : {
          "description" : "Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered matches.",
          "default" : -1.0,
          "type" : "number"
        },
        "ordered" : {
          "description" : "If `true`, intervals produced by the rules should appear in the order in which they are specified.",
          "default" : false,
          "type" : "boolean"
        },
        "filter" : {
          "description" : "Rule used to filter returned intervals.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsFilter"
          } ]
        }
      },
      "required" : [ "intervals" ]
    },
    "_types.mapping.DenseVectorIndexOptions" : {
      "type" : "object",
      "properties" : {
        "confidence_interval" : {
          "description" : "The confidence interval to use when quantizing the vectors. Can be any value between and including `0.90` and\n`1.0` or exactly `0`. When the value is `0`, this indicates that dynamic quantiles should be calculated for\noptimized quantization. When between `0.90` and `1.0`, this value restricts the values used when calculating\nthe quantization thresholds.\n\nFor example, a value of `0.95` will only use the middle `95%` of the values when calculating the quantization\nthresholds (e.g. the highest and lowest `2.5%` of values will be ignored).\n\nDefaults to `1/(dims + 1)` for `int8` quantized vectors and `0` for `int4` for dynamic quantile calculation.\n\nOnly applicable to `int8_hnsw`, `int4_hnsw`, `int8_flat`, and `int4_flat` index types.",
          "type" : "number"
        },
        "ef_construction" : {
          "description" : "The number of candidates to track while assembling the list of nearest neighbors for each new node.\n\nOnly applicable to `hnsw`, `int8_hnsw`, `bbq_hnsw`, and `int4_hnsw` index types.",
          "default" : 100.0,
          "type" : "number"
        },
        "m" : {
          "description" : "The number of neighbors each node will be connected to in the HNSW graph.\n\nOnly applicable to `hnsw`, `int8_hnsw`, `bbq_hnsw`, and `int4_hnsw` index types.",
          "default" : 16.0,
          "type" : "number"
        },
        "type" : {
          "description" : "The type of kNN algorithm to use.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.mapping.DenseVectorIndexOptionsType"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.IcuAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "icu_analyzer" ]
        },
        "method" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.IcuNormalizationType"
          } ]
        },
        "mode" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.IcuNormalizationMode"
          } ]
        }
      },
      "required" : [ "type", "method", "mode" ]
    },
    "_types.analysis.TurkishAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "turkish" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.SpanQuery" : {
      "type" : "object",
      "properties" : {
        "span_containing" : {
          "description" : "Accepts a list of span queries, but only returns those spans which also match a second span query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanContainingQuery"
          } ]
        },
        "span_field_masking" : {
          "description" : "Allows queries like `span_near` or `span_or` across different fields.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanFieldMaskingQuery"
          } ]
        },
        "span_first" : {
          "description" : "Accepts another span query whose matches must appear within the first N positions of the field.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanFirstQuery"
          } ]
        },
        "span_gap" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanGapQuery"
          } ]
        },
        "span_multi" : {
          "description" : "Wraps a `term`, `range`, `prefix`, `wildcard`, `regexp`, or `fuzzy` query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanMultiTermQuery"
          } ]
        },
        "span_near" : {
          "description" : "Accepts multiple span queries whose matches must be within the specified distance of each other, and possibly in the same order.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanNearQuery"
          } ]
        },
        "span_not" : {
          "description" : "Wraps another span query, and excludes any documents which match that query.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanNotQuery"
          } ]
        },
        "span_or" : {
          "description" : "Combines multiple span queriesâ€‰andâ€‰returns documents which match any of the specified queries.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanOrQuery"
          } ]
        },
        "span_term" : {
          "description" : "The equivalent of the `term` query but for use with other span queries.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.query_dsl.SpanTermQuery"
          },
          "minProperties" : 1,
          "maxProperties" : 1
        },
        "span_within" : {
          "description" : "The result from a single span query is returned as long is its span falls within the spans returned by a list of other span queries.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.SpanWithinQuery"
          } ]
        }
      },
      "minProperties" : 1,
      "maxProperties" : 1
    },
    "_types.analysis.GalicianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "galician" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.IcuCollationAlternate" : {
      "type" : "string",
      "enum" : [ "shifted", "non-ignorable" ]
    },
    "_types.analysis.LowercaseNormalizer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "lowercase" ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.BulgarianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "bulgarian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.GeoPointMetricType" : {
      "type" : "string",
      "enum" : [ "gauge", "counter", "position" ]
    },
    "_types.analysis.EstonianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "estonian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.MultiTermQueryRewrite" : {
      "type" : "string"
    },
    "_types.analysis.HindiAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "hindi" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.MinimumShouldMatch" : {
      "description" : "The minimum number of terms that should match as integer, percentage or range",
      "oneOf" : [ {
        "type" : "number"
      }, {
        "type" : "string"
      } ]
    },
    "_types.IBLambda" : {
      "type" : "string",
      "enum" : [ "df", "ttf" ]
    },
    "_types.mapping.GeoStrategy" : {
      "type" : "string",
      "enum" : [ "recursive", "term" ]
    },
    "_types.analysis.IndonesianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "indonesian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.RankFeatureFunctionLinear" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunction"
      }, {
        "type" : "object"
      } ]
    },
    "_types.mapping.OnScriptError" : {
      "type" : "string",
      "enum" : [ "fail", "continue" ]
    },
    "_types.mapping.DenseVectorSimilarity" : {
      "type" : "string",
      "enum" : [ "cosine", "dot_product", "l2_norm", "max_inner_product" ]
    },
    "_global.search._types.InnerHits" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "description" : "The name for the particular inner hit definition in the response.\nUseful when a search request contains multiple inner hits.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Name"
          } ]
        },
        "size" : {
          "description" : "The maximum number of hits to return per `inner_hits`.",
          "default" : 3.0,
          "type" : "number"
        },
        "from" : {
          "description" : "Inner hit starting document offset.",
          "default" : 0.0,
          "type" : "number"
        },
        "collapse" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.FieldCollapse"
          } ]
        },
        "docvalue_fields" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/_types.query_dsl.FieldAndFormat"
          }
        },
        "explain" : {
          "type" : "boolean"
        },
        "highlight" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.Highlight"
          } ]
        },
        "ignore_unmapped" : {
          "type" : "boolean"
        },
        "script_fields" : {
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/_types.ScriptField"
          }
        },
        "seq_no_primary_term" : {
          "type" : "boolean"
        },
        "fields" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/_types.Field"
          }
        },
        "sort" : {
          "description" : "How the inner hits should be sorted per `inner_hits`.\nBy default, inner hits are sorted by score.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Sort"
          } ]
        },
        "_source" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.SourceConfig"
          } ]
        },
        "stored_fields" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Fields"
          } ]
        },
        "track_scores" : {
          "default" : false,
          "type" : "boolean"
        },
        "version" : {
          "type" : "boolean"
        }
      }
    },
    "_types.analysis.IrishAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "irish" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.mapping.TextIndexPrefixes" : {
      "type" : "object",
      "properties" : {
        "max_chars" : {
          "type" : "number"
        },
        "min_chars" : {
          "type" : "number"
        }
      },
      "required" : [ "max_chars", "min_chars" ]
    },
    "_types.query_dsl.DateDistanceFeatureQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.DistanceFeatureQueryBaseDateMathDuration"
      }, {
        "type" : "object"
      } ]
    },
    "_types.analysis.EnglishAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "english" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.TokenFilterDefinition" : {
      "discriminator" : {
        "propertyName" : "type",
        "mapping" : {
          "apostrophe" : "#/components/schemas/_types.analysis.ApostropheTokenFilter",
          "arabic_normalization" : "#/components/schemas/_types.analysis.ArabicNormalizationTokenFilter",
          "arabic_stem" : "#/components/schemas/_types.analysis.ArabicStemTokenFilter",
          "asciifolding" : "#/components/schemas/_types.analysis.AsciiFoldingTokenFilter",
          "bengali_normalization" : "#/components/schemas/_types.analysis.BengaliNormalizationTokenFilter",
          "brazilian_stem" : "#/components/schemas/_types.analysis.BrazilianStemTokenFilter",
          "cjk_bigram" : "#/components/schemas/_types.analysis.CjkBigramTokenFilter",
          "cjk_width" : "#/components/schemas/_types.analysis.CjkWidthTokenFilter",
          "classic" : "#/components/schemas/_types.analysis.ClassicTokenFilter",
          "common_grams" : "#/components/schemas/_types.analysis.CommonGramsTokenFilter",
          "condition" : "#/components/schemas/_types.analysis.ConditionTokenFilter",
          "czech_stem" : "#/components/schemas/_types.analysis.CzechStemTokenFilter",
          "decimal_digit" : "#/components/schemas/_types.analysis.DecimalDigitTokenFilter",
          "delimited_payload" : "#/components/schemas/_types.analysis.DelimitedPayloadTokenFilter",
          "dictionary_decompounder" : "#/components/schemas/_types.analysis.DictionaryDecompounderTokenFilter",
          "dutch_stem" : "#/components/schemas/_types.analysis.DutchStemTokenFilter",
          "edge_ngram" : "#/components/schemas/_types.analysis.EdgeNGramTokenFilter",
          "elision" : "#/components/schemas/_types.analysis.ElisionTokenFilter",
          "fingerprint" : "#/components/schemas/_types.analysis.FingerprintTokenFilter",
          "flatten_graph" : "#/components/schemas/_types.analysis.FlattenGraphTokenFilter",
          "french_stem" : "#/components/schemas/_types.analysis.FrenchStemTokenFilter",
          "german_normalization" : "#/components/schemas/_types.analysis.GermanNormalizationTokenFilter",
          "german_stem" : "#/components/schemas/_types.analysis.GermanStemTokenFilter",
          "hindi_normalization" : "#/components/schemas/_types.analysis.HindiNormalizationTokenFilter",
          "hunspell" : "#/components/schemas/_types.analysis.HunspellTokenFilter",
          "hyphenation_decompounder" : "#/components/schemas/_types.analysis.HyphenationDecompounderTokenFilter",
          "icu_collation" : "#/components/schemas/_types.analysis.IcuCollationTokenFilter",
          "icu_folding" : "#/components/schemas/_types.analysis.IcuFoldingTokenFilter",
          "icu_normalizer" : "#/components/schemas/_types.analysis.IcuNormalizationTokenFilter",
          "icu_transform" : "#/components/schemas/_types.analysis.IcuTransformTokenFilter",
          "indic_normalization" : "#/components/schemas/_types.analysis.IndicNormalizationTokenFilter",
          "ja_stop" : "#/components/schemas/_types.analysis.JaStopTokenFilter",
          "keep" : "#/components/schemas/_types.analysis.KeepWordsTokenFilter",
          "keep_types" : "#/components/schemas/_types.analysis.KeepTypesTokenFilter",
          "keyword_marker" : "#/components/schemas/_types.analysis.KeywordMarkerTokenFilter",
          "keyword_repeat" : "#/components/schemas/_types.analysis.KeywordRepeatTokenFilter",
          "kstem" : "#/components/schemas/_types.analysis.KStemTokenFilter",
          "kuromoji_part_of_speech" : "#/components/schemas/_types.analysis.KuromojiPartOfSpeechTokenFilter",
          "kuromoji_readingform" : "#/components/schemas/_types.analysis.KuromojiReadingFormTokenFilter",
          "kuromoji_stemmer" : "#/components/schemas/_types.analysis.KuromojiStemmerTokenFilter",
          "length" : "#/components/schemas/_types.analysis.LengthTokenFilter",
          "limit" : "#/components/schemas/_types.analysis.LimitTokenCountTokenFilter",
          "lowercase" : "#/components/schemas/_types.analysis.LowercaseTokenFilter",
          "min_hash" : "#/components/schemas/_types.analysis.MinHashTokenFilter",
          "multiplexer" : "#/components/schemas/_types.analysis.MultiplexerTokenFilter",
          "ngram" : "#/components/schemas/_types.analysis.NGramTokenFilter",
          "nori_part_of_speech" : "#/components/schemas/_types.analysis.NoriPartOfSpeechTokenFilter",
          "pattern_capture" : "#/components/schemas/_types.analysis.PatternCaptureTokenFilter",
          "pattern_replace" : "#/components/schemas/_types.analysis.PatternReplaceTokenFilter",
          "persian_normalization" : "#/components/schemas/_types.analysis.PersianNormalizationTokenFilter",
          "persian_stem" : "#/components/schemas/_types.analysis.PersianStemTokenFilter",
          "phonetic" : "#/components/schemas/_types.analysis.PhoneticTokenFilter",
          "porter_stem" : "#/components/schemas/_types.analysis.PorterStemTokenFilter",
          "predicate_token_filter" : "#/components/schemas/_types.analysis.PredicateTokenFilter",
          "remove_duplicates" : "#/components/schemas/_types.analysis.RemoveDuplicatesTokenFilter",
          "reverse" : "#/components/schemas/_types.analysis.ReverseTokenFilter",
          "russian_stem" : "#/components/schemas/_types.analysis.RussianStemTokenFilter",
          "scandinavian_folding" : "#/components/schemas/_types.analysis.ScandinavianFoldingTokenFilter",
          "scandinavian_normalization" : "#/components/schemas/_types.analysis.ScandinavianNormalizationTokenFilter",
          "serbian_normalization" : "#/components/schemas/_types.analysis.SerbianNormalizationTokenFilter",
          "shingle" : "#/components/schemas/_types.analysis.ShingleTokenFilter",
          "snowball" : "#/components/schemas/_types.analysis.SnowballTokenFilter",
          "sorani_normalization" : "#/components/schemas/_types.analysis.SoraniNormalizationTokenFilter",
          "stemmer" : "#/components/schemas/_types.analysis.StemmerTokenFilter",
          "stemmer_override" : "#/components/schemas/_types.analysis.StemmerOverrideTokenFilter",
          "stop" : "#/components/schemas/_types.analysis.StopTokenFilter",
          "synonym" : "#/components/schemas/_types.analysis.SynonymTokenFilter",
          "synonym_graph" : "#/components/schemas/_types.analysis.SynonymGraphTokenFilter",
          "trim" : "#/components/schemas/_types.analysis.TrimTokenFilter",
          "truncate" : "#/components/schemas/_types.analysis.TruncateTokenFilter",
          "unique" : "#/components/schemas/_types.analysis.UniqueTokenFilter",
          "uppercase" : "#/components/schemas/_types.analysis.UppercaseTokenFilter",
          "word_delimiter" : "#/components/schemas/_types.analysis.WordDelimiterTokenFilter",
          "word_delimiter_graph" : "#/components/schemas/_types.analysis.WordDelimiterGraphTokenFilter"
        }
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.analysis.ApostropheTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ArabicStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ArabicNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.AsciiFoldingTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.BengaliNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.BrazilianStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.CjkBigramTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.CjkWidthTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ClassicTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.CommonGramsTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ConditionTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.CzechStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.DecimalDigitTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.DelimitedPayloadTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.DutchStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.EdgeNGramTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ElisionTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.FingerprintTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.FlattenGraphTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.FrenchStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.GermanNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.GermanStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.HindiNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.HunspellTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.HyphenationDecompounderTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.IndicNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KeepTypesTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KeepWordsTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KeywordMarkerTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KeywordRepeatTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.LengthTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.LimitTokenCountTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.LowercaseTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.MinHashTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.MultiplexerTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.NGramTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.NoriPartOfSpeechTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PatternCaptureTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PatternReplaceTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PersianNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PersianStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PorterStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PredicateTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.RemoveDuplicatesTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ReverseTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.RussianStemTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ScandinavianFoldingTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ScandinavianNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.SerbianNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.ShingleTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.SnowballTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.SoraniNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.StemmerOverrideTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.StemmerTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.StopTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.SynonymGraphTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.SynonymTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.TrimTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.TruncateTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.UniqueTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.UppercaseTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.WordDelimiterGraphTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.WordDelimiterTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.JaStopTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KuromojiStemmerTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KuromojiReadingFormTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KuromojiPartOfSpeechTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.IcuCollationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.IcuFoldingTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.IcuNormalizationTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.IcuTransformTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PhoneticTokenFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.DictionaryDecompounderTokenFilter"
      } ],
      "defaultSnippets" : [ {
        "label" : "add new token filter",
        "body" : {
          "type" : "$1"
        }
      } ]
    },
    "_types.QueryVectorBuilder" : {
      "type" : "object",
      "properties" : {
        "text_embedding" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.TextEmbedding"
          } ]
        }
      },
      "minProperties" : 1,
      "maxProperties" : 1
    },
    "_types.query_dsl.NumberRangeQuery" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RangeQueryBasedouble"
      }, {
        "type" : "object"
      } ]
    },
    "_types.analysis.KuromojiAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "kuromoji" ]
        },
        "mode" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.KuromojiTokenizationMode"
          } ]
        },
        "user_dictionary" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.CharFilterDefinition" : {
      "discriminator" : {
        "propertyName" : "type",
        "mapping" : {
          "html_strip" : "#/components/schemas/_types.analysis.HtmlStripCharFilter",
          "icu_normalizer" : "#/components/schemas/_types.analysis.IcuNormalizationCharFilter",
          "kuromoji_iteration_mark" : "#/components/schemas/_types.analysis.KuromojiIterationMarkCharFilter",
          "mapping" : "#/components/schemas/_types.analysis.MappingCharFilter",
          "pattern_replace" : "#/components/schemas/_types.analysis.PatternReplaceCharFilter"
        }
      },
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.analysis.HtmlStripCharFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.MappingCharFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.PatternReplaceCharFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.IcuNormalizationCharFilter"
      }, {
        "$ref" : "#/definitions/_types.analysis.KuromojiIterationMarkCharFilter"
      } ],
      "properties" : {
        "type" : {
          "type" : "string",
          "examples" : [ "html_strip", "mapping", "pattern_replace", "icu_normalizer", "kuromoji_iteration_mark" ]
        }
      }
    },
    "indices._types.IndexRoutingAllocationInclude" : {
      "type" : "object",
      "properties" : {
        "_tier_preference" : {
          "type" : "string"
        },
        "_id" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Id"
          } ]
        }
      }
    },
    "_types.GeoHexCell" : {
      "description" : "A map hex cell (H3) reference",
      "type" : "string"
    },
    "_types.ScriptLanguage" : {
      "anyOf" : [ {
        "type" : "string",
        "enum" : [ "painless", "expression", "mustache", "java" ]
      }, {
        "type" : "string"
      } ]
    },
    "_types.query_dsl.IntervalsRange" : {
      "type" : "object",
      "properties" : {
        "analyzer" : {
          "description" : "Analyzer used to analyze the `prefix`.",
          "type" : "string"
        },
        "gte" : {
          "description" : "Lower term, either gte or gt must be provided.",
          "type" : "string"
        },
        "gt" : {
          "description" : "Lower term, either gte or gt must be provided.",
          "type" : "string"
        },
        "lte" : {
          "description" : "Upper term, either lte or lt must be provided.",
          "type" : "string"
        },
        "lt" : {
          "description" : "Upper term, either lte or lt must be provided.",
          "type" : "string"
        },
        "use_field" : {
          "description" : "If specified, match intervals from this field rather than the top-level field.\nThe `prefix` is normalized using the search analyzer from this field, unless `analyzer` is specified separately.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        }
      }
    },
    "_types.analysis.IcuCollationStrength" : {
      "type" : "string",
      "enum" : [ "primary", "secondary", "tertiary", "quaternary", "identical" ]
    },
    "_types.analysis.SerbianAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "serbian" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "_types.query_dsl.RankFeatureFunctionLogarithm" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.RankFeatureFunction"
      }, {
        "type" : "object",
        "properties" : {
          "scaling_factor" : {
            "description" : "Configurable scaling factor.",
            "type" : "number"
          }
        },
        "required" : [ "scaling_factor" ]
      } ]
    },
    "_types.analysis.StopWords" : {
      "description" : "Language value, such as _arabic_ or _thai_. Defaults to _english_.\nEach language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words.\nAlso accepts an array of stop words.",
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.analysis.StopWordLanguage"
      }, {
        "type" : "array",
        "items" : {
          "type" : "string"
        }
      } ],
      "defaultSnippets" : [ {
        "label" : "define stop words list",
        "body" : [ "$1" ]
      } ]
    },
    "_types.RelationName" : {
      "type" : "string"
    },
    "_types.analysis.SimpleAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "simple" ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.CjkAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "cjk" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        }
      },
      "required" : [ "type" ]
    },
    "_types.analysis.FinnishAnalyzer" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "enum" : [ "finnish" ]
        },
        "stopwords" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.analysis.StopWords"
          } ]
        },
        "stopwords_path" : {
          "type" : "string"
        },
        "stem_exclusion" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      },
      "required" : [ "type" ]
    },
    "indices._types.NumericFielddata" : {
      "type" : "object",
      "properties" : {
        "format" : {
          "allOf" : [ {
            "$ref" : "#/definitions/indices._types.NumericFielddataFormat"
          } ]
        }
      },
      "required" : [ "format" ]
    },
    "_types.analysis.RemoveDuplicatesTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "remove_duplicates" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.CommonGramsTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "common_grams" ]
          },
          "common_words" : {
            "description" : "A list of tokens. The filter generates bigrams for these tokens.\nEither this or the `common_words_path` parameter is required.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "common_words_path" : {
            "description" : "Path to a file containing a list of tokens. The filter generates bigrams for these tokens.\nThis path must be absolute or relative to the `config` location. The file must be UTF-8 encoded. Each token in the file must be separated by a line break.\nEither this or the `common_words` parameter is required.",
            "type" : "string"
          },
          "ignore_case" : {
            "description" : "If `true`, matches for common words matching are case-insensitive. Defaults to `false`.",
            "type" : "boolean"
          },
          "query_mode" : {
            "description" : "If `true`, the filter excludes the following tokens from the output:\n- Unigrams for common words\n- Unigrams for terms followed by common words\nDefaults to `false`. We recommend enabling this parameter for search analyzers.",
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.IcuTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "icu_tokenizer" ]
          },
          "rule_files" : {
            "type" : "string"
          }
        },
        "required" : [ "type", "rule_files" ]
      } ]
    },
    "_types.analysis.FingerprintTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "fingerprint" ]
          },
          "max_output_size" : {
            "description" : "Maximum character length, including whitespace, of the output token. Defaults to `255`. Concatenated tokens longer than this will result in no token output.",
            "type" : "number"
          },
          "separator" : {
            "description" : "Character to use to concatenate the token stream input. Defaults to a space.",
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.LowercaseTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "lowercase" ]
          },
          "language" : {
            "description" : "Language-specific lowercase token filter to use.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.LowercaseTokenFilterLanguages"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.TruncateTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "truncate" ]
          },
          "length" : {
            "description" : "Character limit for each token. Tokens exceeding this limit are truncated. Defaults to `10`.",
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.ClassicTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "classic" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.PhoneticTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "phonetic" ]
          },
          "encoder" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.PhoneticEncoder"
            } ]
          },
          "languageset" : {
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.analysis.PhoneticLanguage"
            }, {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/_types.analysis.PhoneticLanguage"
              }
            } ]
          },
          "max_code_len" : {
            "type" : "number"
          },
          "name_type" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.PhoneticNameType"
            } ]
          },
          "replace" : {
            "type" : "boolean"
          },
          "rule_type" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.PhoneticRuleType"
            } ]
          }
        },
        "required" : [ "type", "encoder" ]
      } ]
    },
    "_types.query_dsl.RangeQueryBasedouble" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "relation" : {
            "description" : "Indicates how the range query matches values for `range` fields.",
            "default" : "intersects",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RangeRelation"
            } ]
          },
          "gt" : {
            "description" : "Greater than.",
            "type" : "number"
          },
          "gte" : {
            "description" : "Greater than or equal to.",
            "type" : "number"
          },
          "lt" : {
            "description" : "Less than.",
            "type" : "number"
          },
          "lte" : {
            "description" : "Less than or equal to.",
            "type" : "number"
          },
          "from" : {
            "deprecated" : true,
            "oneOf" : [ {
              "type" : "number"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          },
          "to" : {
            "deprecated" : true,
            "oneOf" : [ {
              "type" : "number"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          }
        }
      } ]
    },
    "_types.analysis.StemmerTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "stemmer" ]
          },
          "language" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.WordDelimiterGraphTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.WordDelimiterTokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "word_delimiter_graph" ]
          },
          "adjust_offsets" : {
            "description" : "If `true`, the filter adjusts the offsets of split or catenated tokens to better reflect their actual position in the token stream. Defaults to `true`.",
            "type" : "boolean"
          },
          "ignore_keywords" : {
            "description" : "If `true`, the filter skips tokens with a keyword attribute of true. Defaults to `false`.",
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.HtmlStripCharFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CharFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "html_strip" ]
          },
          "escaped_tags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "defaultSnippets" : [ {
              "body" : [ "${1:b}" ]
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.PatternTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "pattern" ]
          },
          "flags" : {
            "type" : "string"
          },
          "group" : {
            "type" : "number"
          },
          "pattern" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KuromojiTokenizationMode" : {
      "type" : "string",
      "enum" : [ "normal", "search", "extended" ]
    },
    "_types.query_dsl.LikeDocument" : {
      "type" : "object",
      "properties" : {
        "doc" : {
          "description" : "A document not present in the index.",
          "type" : "object"
        },
        "fields" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/_types.Field"
          }
        },
        "_id" : {
          "description" : "ID of a document.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Id"
          } ]
        },
        "_index" : {
          "description" : "Index of a document.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.IndexName"
          } ]
        },
        "per_field_analyzer" : {
          "description" : "Overrides the default analyzer.",
          "type" : "object",
          "additionalProperties" : {
            "type" : "string"
          }
        },
        "routing" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Routing"
          } ]
        },
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionNumber"
          } ]
        },
        "version_type" : {
          "default" : "'internal'",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionType"
          } ]
        }
      }
    },
    "_types.query_dsl.SpanGapQuery" : {
      "description" : "Can only be used as a clause in a span_near query.",
      "type" : "object",
      "additionalProperties" : {
        "type" : "number"
      },
      "minProperties" : 1,
      "maxProperties" : 1
    },
    "_types.analysis.PatternCaptureTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "pattern_capture" ]
          },
          "patterns" : {
            "description" : "A list of regular expressions to match.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "preserve_original" : {
            "description" : "If set to `true` (the default) it will emit the original token.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          }
        },
        "required" : [ "type", "patterns" ]
      } ]
    },
    "_types.analysis.NGramTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "ngram" ]
          },
          "max_gram" : {
            "description" : "Maximum length of characters in a gram. Defaults to `2`.",
            "type" : "number"
          },
          "min_gram" : {
            "description" : "Minimum length of characters in a gram. Defaults to `1`.",
            "type" : "number"
          },
          "preserve_original" : {
            "description" : "Emits original token when set to `true`. Defaults to `false`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.IcuTransformTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "icu_transform" ]
          },
          "dir" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuTransformDirection"
            } ]
          },
          "id" : {
            "type" : "string"
          }
        },
        "required" : [ "type", "id" ]
      } ]
    },
    "_types.analysis.BengaliNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "bengali_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.UppercaseTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "uppercase" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.JaStopTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "ja_stop" ]
          },
          "stopwords" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.StopWords"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KuromojiPartOfSpeechTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "kuromoji_part_of_speech" ]
          },
          "stoptags" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "type", "stoptags" ]
      } ]
    },
    "_types.analysis.NoriPartOfSpeechTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "nori_part_of_speech" ]
          },
          "stoptags" : {
            "description" : "An array of part-of-speech tags that should be removed.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.SnowballLanguage" : {
      "type" : "string",
      "enum" : [ "Arabic", "Armenian", "Basque", "Catalan", "Danish", "Dutch", "English", "Estonian", "Finnish", "French", "German", "German2", "Hungarian", "Italian", "Irish", "Kp", "Lithuanian", "Lovins", "Norwegian", "Porter", "Portuguese", "Romanian", "Russian", "Serbian", "Spanish", "Swedish", "Turkish" ]
    },
    "_types.analysis.KeywordTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "keyword" ]
          },
          "buffer_size" : {
            "default" : 256.0,
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.RangeQueryBaseDateMath" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "relation" : {
            "description" : "Indicates how the range query matches values for `range` fields.",
            "default" : "intersects",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RangeRelation"
            } ]
          },
          "gt" : {
            "description" : "Greater than.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateMath"
            } ]
          },
          "gte" : {
            "description" : "Greater than or equal to.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateMath"
            } ]
          },
          "lt" : {
            "description" : "Less than.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateMath"
            } ]
          },
          "lte" : {
            "description" : "Less than or equal to.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateMath"
            } ]
          },
          "from" : {
            "deprecated" : true,
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.DateMath"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          },
          "to" : {
            "deprecated" : true,
            "oneOf" : [ {
              "$ref" : "#/definitions/_types.DateMath"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          }
        }
      } ]
    },
    "_types.ScriptField" : {
      "type" : "object",
      "properties" : {
        "script" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Script"
          } ]
        },
        "ignore_failure" : {
          "type" : "boolean"
        }
      },
      "required" : [ "script" ]
    },
    "_types.query_dsl.RangeQueryBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "relation" : {
            "description" : "Indicates how the range query matches values for `range` fields.",
            "default" : "intersects",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RangeRelation"
            } ]
          },
          "gt" : {
            "description" : "Greater than.",
            "type" : "object"
          },
          "gte" : {
            "description" : "Greater than or equal to.",
            "type" : "object"
          },
          "lt" : {
            "description" : "Less than.",
            "type" : "object"
          },
          "lte" : {
            "description" : "Less than or equal to.",
            "type" : "object"
          },
          "from" : {
            "deprecated" : true,
            "oneOf" : [ {
              "type" : "object"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          },
          "to" : {
            "deprecated" : true,
            "oneOf" : [ {
              "type" : "object"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          }
        }
      } ]
    },
    "_types.analysis.DictionaryDecompounderTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CompoundWordTokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "dictionary_decompounder" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KuromojiIterationMarkCharFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CharFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "kuromoji_iteration_mark" ]
          },
          "normalize_kana" : {
            "type" : "boolean"
          },
          "normalize_kanji" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type", "normalize_kana", "normalize_kanji" ]
      } ]
    },
    "_types.analysis.MinHashTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "min_hash" ]
          },
          "bucket_count" : {
            "description" : "Number of buckets to which hashes are assigned. Defaults to `512`.",
            "type" : "number"
          },
          "hash_count" : {
            "description" : "Number of ways to hash each token in the stream. Defaults to `1`.",
            "type" : "number"
          },
          "hash_set_size" : {
            "description" : "Number of hashes to keep from each bucket. Defaults to `1`.\nHashes are retained by ascending size, starting with the bucketâ€™s smallest hash first.",
            "type" : "number"
          },
          "with_rotation" : {
            "description" : "If `true`, the filter fills empty buckets with the value of the first non-empty bucket to its circular right if the `hash_set_size` is `1`. If the `bucket_count` argument is greater than 1, this parameter defaults to `true`. Otherwise, this parameter defaults to `false`.",
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.PorterStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "porter_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.UniqueTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "unique" ]
          },
          "only_on_same_position" : {
            "description" : "If `true`, only remove duplicate tokens in the same position. Defaults to `false`.",
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.StopTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "stop" ]
          },
          "ignore_case" : {
            "description" : "If `true`, stop word matching is case insensitive. For example, if `true`, a stop word of the matches and removes `The`, `THE`, or `the`. Defaults to `false`.",
            "type" : "boolean"
          },
          "remove_trailing" : {
            "description" : "If `true`, the last token of a stream is removed if itâ€™s a stop word. Defaults to `true`.",
            "type" : "boolean"
          },
          "stopwords" : {
            "description" : "Language value, such as `_arabic_` or `_thai_`. Defaults to `_english_`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.StopWords"
            } ]
          },
          "stopwords_path" : {
            "description" : "Path to a file that contains a list of stop words to remove.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each stop word in the file must be separated by a line break.",
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.ArabicStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "arabic_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.ScriptScoreFunction" : {
      "type" : "object",
      "properties" : {
        "script" : {
          "description" : "A script that computes a score.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Script"
          } ]
        }
      },
      "required" : [ "script" ]
    },
    "_types.analysis.DelimitedPayloadTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "delimited_payload" ]
          },
          "delimiter" : {
            "description" : "Character used to separate tokens from payloads. Defaults to `|`.",
            "type" : "string"
          },
          "encoding" : {
            "description" : "Data type for the stored payload.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.DelimitedPayloadEncoding"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.IcuCollationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "icu_collation" ]
          },
          "alternate" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationAlternate"
            } ]
          },
          "caseFirst" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationCaseFirst"
            } ]
          },
          "caseLevel" : {
            "type" : "boolean"
          },
          "country" : {
            "type" : "string"
          },
          "decomposition" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationDecomposition"
            } ]
          },
          "hiraganaQuaternaryMode" : {
            "type" : "boolean"
          },
          "language" : {
            "type" : "string"
          },
          "numeric" : {
            "type" : "boolean"
          },
          "rules" : {
            "type" : "string"
          },
          "strength" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuCollationStrength"
            } ]
          },
          "variableTop" : {
            "type" : "string"
          },
          "variant" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.CharGroupTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "char_group" ]
          },
          "tokenize_on_chars" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "max_token_length" : {
            "type" : "number"
          }
        },
        "required" : [ "type", "tokenize_on_chars" ]
      } ]
    },
    "_types.analysis.KeepTypesTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "keep_types" ]
          },
          "mode" : {
            "description" : "Indicates whether to keep or remove the specified token types.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.KeepTypesMode"
            } ]
          },
          "types" : {
            "description" : "List of token types to keep or remove.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "type", "types" ]
      } ]
    },
    "_types.query_dsl.IntervalsContainer" : {
      "type" : "object",
      "properties" : {
        "all_of" : {
          "description" : "Returns matches that span a combination of other rules.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsAllOf"
          } ]
        },
        "any_of" : {
          "description" : "Returns intervals produced by any of its sub-rules.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsAnyOf"
          } ]
        },
        "fuzzy" : {
          "description" : "Matches analyzed text.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsFuzzy"
          } ]
        },
        "match" : {
          "description" : "Matches analyzed text.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsMatch"
          } ]
        },
        "prefix" : {
          "description" : "Matches terms that start with a specified set of characters.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsPrefix"
          } ]
        },
        "range" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsRange"
          } ]
        },
        "regexp" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsRegexp"
          } ]
        },
        "wildcard" : {
          "description" : "Matches terms using a wildcard pattern.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsWildcard"
          } ]
        }
      },
      "minProperties" : 1,
      "maxProperties" : 1
    },
    "_types.analysis.SnowballTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "snowball" ]
          },
          "language" : {
            "description" : "Controls the language used by the stemmer.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.SnowballLanguage"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.DistanceFeatureQueryBaseDateMathDuration" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "origin" : {
            "description" : "Date or point of origin used to calculate distances.\nIf the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date.\nDate Math, such as `now-1h`, is supported.\nIf the field value is a `geo_point` field, the `origin` value must be a geopoint.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.DateMath"
            } ]
          },
          "pivot" : {
            "description" : "Distance from the `origin` at which relevance scores receive half of the `boost` value.\nIf the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Duration"
            } ]
          },
          "field" : {
            "description" : "Name of the field used to calculate distances. This field must meet the following criteria:\nbe a `date`, `date_nanos` or `geo_point` field;\nhave an `index` mapping parameter value of `true`, which is the default;\nhave an `doc_values` mapping parameter value of `true`, which is the default.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          }
        },
        "required" : [ "origin", "pivot", "field" ]
      } ]
    },
    "_types.analysis.FrenchStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "french_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.ShingleTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "shingle" ]
          },
          "filler_token" : {
            "description" : "String used in shingles as a replacement for empty positions that do not contain a token. This filler token is only used in shingles, not original unigrams. Defaults to an underscore (`_`).",
            "type" : "string"
          },
          "max_shingle_size" : {
            "description" : "Maximum number of tokens to concatenate when creating shingles. Defaults to `2`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
            } ]
          },
          "min_shingle_size" : {
            "description" : "Minimum number of tokens to concatenate when creating shingles. Defaults to `2`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
            } ]
          },
          "output_unigrams" : {
            "description" : "If `true`, the output includes the original input tokens. If `false`, the output only includes shingles; the original input tokens are removed. Defaults to `true`.",
            "type" : "boolean"
          },
          "output_unigrams_if_no_shingles" : {
            "description" : "If `true`, the output includes the original input tokens only if no shingles are produced; if shingles are produced, the output only includes shingles. Defaults to `false`.",
            "type" : "boolean"
          },
          "token_separator" : {
            "description" : "Separator used to concatenate adjacent tokens to form a shingle. Defaults to a space (`\" \"`).",
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.BrazilianStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "brazilian_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "indices._types.NumericFielddataFormat" : {
      "type" : "string",
      "enum" : [ "array", "disabled" ]
    },
    "_types.mapping.DenseVectorIndexOptionsType" : {
      "type" : "string",
      "enum" : [ "bbq_flat", "bbq_hnsw", "flat", "hnsw", "int4_flat", "int4_hnsw", "int8_flat", "int8_hnsw" ]
    },
    "_global.search._types.SourceConfig" : {
      "description" : "Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.",
      "oneOf" : [ {
        "type" : "boolean"
      }, {
        "$ref" : "#/definitions/_global.search._types.SourceFilter"
      } ]
    },
    "_types.analysis.SimplePatternSplitTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "simple_pattern_split" ]
          },
          "pattern" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.WordDelimiterTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.WordDelimiterTokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "word_delimiter" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.DistanceFeatureQueryBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "origin" : {
            "description" : "Date or point of origin used to calculate distances.\nIf the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date.\nDate Math, such as `now-1h`, is supported.\nIf the field value is a `geo_point` field, the `origin` value must be a geopoint.",
            "type" : "object"
          },
          "pivot" : {
            "description" : "Distance from the `origin` at which relevance scores receive half of the `boost` value.\nIf the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`.",
            "type" : "object"
          },
          "field" : {
            "description" : "Name of the field used to calculate distances. This field must meet the following criteria:\nbe a `date`, `date_nanos` or `geo_point` field;\nhave an `index` mapping parameter value of `true`, which is the default;\nhave an `doc_values` mapping parameter value of `true`, which is the default.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          }
        },
        "required" : [ "origin", "pivot", "field" ]
      } ]
    },
    "_types.query_dsl.DistanceFeatureQueryBaseGeoLocationDistance" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "origin" : {
            "description" : "Date or point of origin used to calculate distances.\nIf the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date.\nDate Math, such as `now-1h`, is supported.\nIf the field value is a `geo_point` field, the `origin` value must be a geopoint.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.GeoLocation"
            } ]
          },
          "pivot" : {
            "description" : "Distance from the `origin` at which relevance scores receive half of the `boost` value.\nIf the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Distance"
            } ]
          },
          "field" : {
            "description" : "Name of the field used to calculate distances. This field must meet the following criteria:\nbe a `date`, `date_nanos` or `geo_point` field;\nhave an `index` mapping parameter value of `true`, which is the default;\nhave an `doc_values` mapping parameter value of `true`, which is the default.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Field"
            } ]
          }
        },
        "required" : [ "origin", "pivot", "field" ]
      } ]
    },
    "_types.analysis.CjkWidthTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "cjk_width" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.GermanNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "german_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_spec_utils.PipeSeparatedFlagsSimpleQueryStringFlag" : {
      "description" : "A set of flags that can be represented as a single enum value or a set of values that are encoded\nas a pipe-separated string\n\nDepending on the target language, code generators can use this hint to generate language specific\nflags enum constructs and the corresponding (de-)serialization code.",
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.SimpleQueryStringFlag"
      }, {
        "type" : "string"
      } ]
    },
    "_types.analysis.RussianStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "russian_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.MultiplexerTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "multiplexer" ]
          },
          "filters" : {
            "description" : "A list of token filters to apply to incoming tokens.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "preserve_original" : {
            "description" : "If `true` (the default) then emit the original token in addition to the filtered tokens.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          }
        },
        "required" : [ "type", "filters" ]
      } ]
    },
    "_types.Sort" : {
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.SortCombinations"
      }, {
        "type" : "array",
        "items" : {
          "$ref" : "#/definitions/_types.SortCombinations"
        }
      } ]
    },
    "_types.analysis.ElisionTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "elision" ]
          },
          "articles" : {
            "description" : "List of elisions to remove.\nTo be removed, the elision must be at the beginning of a token and be immediately followed by an apostrophe. Both the elision and apostrophe are removed.\nFor custom `elision` filters, either this parameter or `articles_path` must be specified.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "articles_path" : {
            "description" : "Path to a file that contains a list of elisions to remove.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each elision in the file must be separated by a line break.\nTo be removed, the elision must be at the beginning of a token and be immediately followed by an apostrophe. Both the elision and apostrophe are removed.\nFor custom `elision` filters, either this parameter or `articles` must be specified.",
            "type" : "string"
          },
          "articles_case" : {
            "description" : "If `true`, elision matching is case insensitive. If `false`, elision matching is case sensitive. Defaults to `false`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.DecimalDigitTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "decimal_digit" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.GermanStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "german_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.LowercaseTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "lowercase" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.mapping.SyntheticSourceKeepEnum" : {
      "type" : "string",
      "enum" : [ "none", "arrays", "all" ]
    },
    "_types.analysis.PatternReplaceTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "pattern_replace" ]
          },
          "all" : {
            "description" : "If `true`, all substrings matching the pattern parameterâ€™s regular expression are replaced. If `false`, the filter replaces only the first matching substring in each token. Defaults to `true`.",
            "type" : "boolean"
          },
          "flags" : {
            "type" : "string"
          },
          "pattern" : {
            "description" : "Regular expression, written in Javaâ€™s regular expression syntax. The filter replaces token substrings matching this pattern with the substring in the `replacement` parameter.",
            "type" : "string"
          },
          "replacement" : {
            "description" : "Replacement substring. Defaults to an empty substring (`\"\"`).",
            "type" : "string"
          }
        },
        "required" : [ "type", "pattern" ]
      } ]
    },
    "_types.analysis.IcuNormalizationType" : {
      "type" : "string",
      "enum" : [ "nfc", "nfkc", "nfkc_cf" ]
    },
    "_types.analysis.TrimTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "trim" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.ThaiTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "thai" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.HyphenationDecompounderTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CompoundWordTokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "hyphenation_decompounder" ]
          },
          "hyphenation_patterns_path" : {
            "description" : "Path to an Apache FOP (Formatting Objects Processor) XML hyphenation pattern file.\nThis path must be absolute or relative to the `config` location. Only FOP v1.2 compatible files are supported.",
            "type" : "string"
          },
          "no_sub_matches" : {
            "description" : "If `true`, do not match sub tokens in tokens that are in the word list. Defaults to `false`.",
            "type" : "boolean"
          },
          "no_overlapping_matches" : {
            "description" : "If `true`, do not allow overlapping tokens. Defaults to `false`.",
            "type" : "boolean"
          }
        },
        "required" : [ "type", "hyphenation_patterns_path" ]
      } ]
    },
    "_types.query_dsl.FieldValueFactorScoreFunction" : {
      "type" : "object",
      "properties" : {
        "field" : {
          "description" : "Field to be extracted from the document.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "factor" : {
          "description" : "Optional factor to multiply the field value with.",
          "default" : 1.0,
          "type" : "number"
        },
        "missing" : {
          "description" : "Value used if the document doesnâ€™t have that field.\nThe modifier and factor are still applied to it as though it were read from the document.",
          "type" : "number"
        },
        "modifier" : {
          "description" : "Modifier to apply to the field value.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.FieldValueFactorModifier"
          } ]
        }
      },
      "required" : [ "field" ]
    },
    "_types.analysis.PersianStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "persian_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.SynonymTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.SynonymTokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "synonym" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.GeoHashLocation" : {
      "type" : "object",
      "properties" : {
        "geohash" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.GeoHash"
          } ]
        }
      },
      "required" : [ "geohash" ]
    },
    "_types.query_dsl.IntervalsFilter" : {
      "type" : "object",
      "properties" : {
        "after" : {
          "description" : "Query used to return intervals that follow an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "before" : {
          "description" : "Query used to return intervals that occur before an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "contained_by" : {
          "description" : "Query used to return intervals contained by an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "containing" : {
          "description" : "Query used to return intervals that contain an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "not_contained_by" : {
          "description" : "Query used to return intervals that are **not** contained by an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "not_containing" : {
          "description" : "Query used to return intervals that do **not** contain an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "not_overlapping" : {
          "description" : "Query used to return intervals that do **not** overlap with an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "overlapping" : {
          "description" : "Query used to return intervals that overlap with an interval from the `filter` rule.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.IntervalsContainer"
          } ]
        },
        "script" : {
          "description" : "Script used to return matching documents.\nThis script must return a boolean value: `true` or `false`.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Script"
          } ]
        }
      },
      "minProperties" : 1,
      "maxProperties" : 1
    },
    "_types.analysis.EdgeNGramTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "edge_ngram" ]
          },
          "max_gram" : {
            "description" : "Maximum character length of a gram. For custom token filters, defaults to `2`. For the built-in edge_ngram filter, defaults to `1`.",
            "type" : "number"
          },
          "min_gram" : {
            "description" : "Minimum character length of a gram. Defaults to `1`.",
            "type" : "number"
          },
          "side" : {
            "description" : "Indicates whether to truncate tokens from the `front` or `back`. Defaults to `front`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.EdgeNGramSide"
            } ]
          },
          "preserve_original" : {
            "description" : "Emits original token when set to `true`. Defaults to `false`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.NoriDecompoundMode" : {
      "type" : "string",
      "enum" : [ "discard", "none", "mixed" ]
    },
    "_types.analysis.LengthTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "length" ]
          },
          "max" : {
            "description" : "Maximum character length of a token. Longer tokens are excluded from the output. Defaults to `Integer.MAX_VALUE`, which is `2^31-1` or `2147483647`.",
            "type" : "number"
          },
          "min" : {
            "description" : "Minimum character length of a token. Shorter tokens are excluded from the output. Defaults to `0`.",
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.TextEmbedding" : {
      "type" : "object",
      "properties" : {
        "model_id" : {
          "description" : "Since Elasticsearch 8.18.0\nModel ID is required for all dense_vector fields but\nmay be inferred for semantic_text fields",
          "x-state" : "Generally available; Added in 8.18.0",
          "type" : "string"
        },
        "model_text" : {
          "type" : "string"
        }
      },
      "required" : [ "model_text" ]
    },
    "_types.analysis.ScandinavianFoldingTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "scandinavian_folding" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.RandomScoreFunction" : {
      "type" : "object",
      "properties" : {
        "field" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "seed" : {
          "oneOf" : [ {
            "type" : "number"
          }, {
            "type" : "string"
          } ]
        }
      }
    },
    "_types.analysis.AsciiFoldingTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "asciifolding" ]
          },
          "preserve_original" : {
            "description" : "If `true`, emit both original tokens and folded tokens. Defaults to `false`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.SynonymGraphTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.SynonymTokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "synonym_graph" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.DecayFunction" : {
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.UntypedDecayFunction"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.DateDecayFunction"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.NumericDecayFunction"
      }, {
        "$ref" : "#/definitions/_types.query_dsl.GeoDecayFunction"
      } ]
    },
    "_types.analysis.KeywordRepeatTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "keyword_repeat" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.LimitTokenCountTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "limit" ]
          },
          "consume_all_tokens" : {
            "description" : "If `true`, the limit filter exhausts the token stream, even if the `max_token_count` has already been reached. Defaults to `false`.",
            "type" : "boolean"
          },
          "max_token_count" : {
            "description" : "Maximum number of tokens to keep. Once this limit is reached, any remaining tokens are excluded from the output. Defaults to `1`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KeywordMarkerTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "keyword_marker" ]
          },
          "ignore_case" : {
            "description" : "If `true`, matching for the `keywords` and `keywords_path` parameters ignores letter case. Defaults to `false`.",
            "type" : "boolean"
          },
          "keywords" : {
            "description" : "Array of keywords. Tokens that match these keywords are not stemmed.\nThis parameter, `keywords_path`, or `keywords_pattern` must be specified. You cannot specify this parameter and `keywords_pattern`.",
            "oneOf" : [ {
              "type" : "string"
            }, {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            } ]
          },
          "keywords_path" : {
            "description" : "Path to a file that contains a list of keywords. Tokens that match these keywords are not stemmed.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each word in the file must be separated by a line break.\nThis parameter, `keywords`, or `keywords_pattern` must be specified. You cannot specify this parameter and `keywords_pattern`.",
            "type" : "string"
          },
          "keywords_pattern" : {
            "description" : "Java regular expression used to match tokens. Tokens that match this expression are marked as keywords and not stemmed.\nThis parameter, `keywords`, or `keywords_path` must be specified. You cannot specify this parameter and `keywords` or `keywords_pattern`.",
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.LetterTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "letter" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.StandardTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "standard" ]
          },
          "max_token_length" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.IndicNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "indic_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.StemmerOverrideTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "stemmer_override" ]
          },
          "rules" : {
            "description" : "A list of mapping rules to use.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "rules_path" : {
            "description" : "A path (either relative to `config` location, or absolute) to a list of mappings.",
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.ClassicTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "classic" ]
          },
          "max_token_length" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.ScandinavianNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "scandinavian_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.IcuNormalizationCharFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CharFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "icu_normalizer" ]
          },
          "mode" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuNormalizationMode"
            } ]
          },
          "name" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuNormalizationType"
            } ]
          },
          "unicode_set_filter" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.SerbianNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "serbian_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "kstem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KuromojiReadingFormTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "kuromoji_readingform" ]
          },
          "use_romaji" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type", "use_romaji" ]
      } ]
    },
    "_types.query_dsl.RangeQueryBasestring" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.QueryBase"
      }, {
        "type" : "object",
        "properties" : {
          "relation" : {
            "description" : "Indicates how the range query matches values for `range` fields.",
            "default" : "intersects",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.query_dsl.RangeRelation"
            } ]
          },
          "gt" : {
            "description" : "Greater than.",
            "type" : "string"
          },
          "gte" : {
            "description" : "Greater than or equal to.",
            "type" : "string"
          },
          "lt" : {
            "description" : "Less than.",
            "type" : "string"
          },
          "lte" : {
            "description" : "Less than or equal to.",
            "type" : "string"
          },
          "from" : {
            "deprecated" : true,
            "oneOf" : [ {
              "type" : "string"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          },
          "to" : {
            "deprecated" : true,
            "oneOf" : [ {
              "type" : "string"
            }, {
              "nullable" : true,
              "type" : "string"
            } ]
          }
        }
      } ]
    },
    "_types.analysis.IcuFoldingTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "icu_folding" ]
          },
          "unicode_set_filter" : {
            "type" : "string"
          }
        },
        "required" : [ "type", "unicode_set_filter" ]
      } ]
    },
    "_types.analysis.ConditionTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "condition" ]
          },
          "filter" : {
            "description" : "Array of token filters. If a token matches the predicate script in the `script` parameter, these filters are applied to the token in the order provided.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "script" : {
            "description" : "Predicate script used to apply token filters. If a token matches this script, the filters in the `filter` parameter are applied to the token.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          }
        },
        "required" : [ "type", "filter", "script" ]
      } ]
    },
    "_types.analysis.KuromojiStemmerTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "kuromoji_stemmer" ]
          },
          "minimum_length" : {
            "type" : "number"
          }
        },
        "required" : [ "type", "minimum_length" ]
      } ]
    },
    "_types.analysis.CzechStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "czech_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KeepWordsTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "keep" ]
          },
          "keep_words" : {
            "description" : "List of words to keep. Only tokens that match words in this list are included in the output.\nEither this parameter or `keep_words_path` must be specified.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "keep_words_case" : {
            "description" : "If `true`, lowercase all keep words. Defaults to `false`.",
            "type" : "boolean"
          },
          "keep_words_path" : {
            "description" : "Path to a file that contains a list of words to keep. Only tokens that match words in this list are included in the output.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each word in the file must be separated by a line break.\nEither this parameter or `keep_words` must be specified.",
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.KuromojiTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "kuromoji_tokenizer" ]
          },
          "discard_punctuation" : {
            "type" : "boolean"
          },
          "mode" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.KuromojiTokenizationMode"
            } ]
          },
          "nbest_cost" : {
            "type" : "number"
          },
          "nbest_examples" : {
            "type" : "string"
          },
          "user_dictionary" : {
            "type" : "string"
          },
          "user_dictionary_rules" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "discard_compound_token" : {
            "type" : "boolean"
          }
        },
        "required" : [ "type", "mode" ]
      } ]
    },
    "_types.analysis.DutchStemTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "dutch_stem" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.IcuNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "icu_normalizer" ]
          },
          "name" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.IcuNormalizationType"
            } ]
          }
        },
        "required" : [ "type", "name" ]
      } ]
    },
    "_types.analysis.PredicateTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "predicate_token_filter" ]
          },
          "script" : {
            "description" : "Script containing a condition used to filter incoming tokens. Only tokens that match this script are included in the output.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Script"
            } ]
          }
        },
        "required" : [ "type", "script" ]
      } ]
    },
    "_types.DateFormat" : {
      "type" : "string"
    },
    "_types.analysis.PatternReplaceCharFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CharFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "pattern_replace" ]
          },
          "flags" : {
            "type" : "string",
            "examples" : [ "CASE_INSENSITIVE|COMMENTS" ]
          },
          "pattern" : {
            "type" : "string",
            "examples" : [ "[0-9]" ]
          },
          "replacement" : {
            "type" : "string",
            "examples" : [ "-$1-" ]
          }
        },
        "required" : [ "type", "pattern" ]
      } ]
    },
    "_types.analysis.HunspellTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "hunspell" ]
          },
          "dedup" : {
            "description" : "If `true`, duplicate tokens are removed from the filterâ€™s output. Defaults to `true`.",
            "type" : "boolean"
          },
          "dictionary" : {
            "description" : "One or more `.dic` files (e.g, `en_US.dic`, my_custom.dic) to use for the Hunspell dictionary.\nBy default, the `hunspell` filter uses all `.dic` files in the `<$ES_PATH_CONF>/hunspell/<locale>` directory specified using the `lang`, `language`, or `locale` parameter.",
            "type" : "string"
          },
          "locale" : {
            "description" : "Locale directory used to specify the `.aff` and `.dic` files for a Hunspell dictionary.",
            "type" : "string"
          },
          "longest_only" : {
            "description" : "If `true`, only the longest stemmed version of each token is included in the output. If `false`, all stemmed versions of the token are included. Defaults to `false`.",
            "type" : "boolean"
          }
        },
        "required" : [ "type", "locale" ]
      } ]
    },
    "_types.analysis.ReverseTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "reverse" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.UaxEmailUrlTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "uax_url_email" ]
          },
          "max_token_length" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.NoriTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "nori_tokenizer" ]
          },
          "decompound_mode" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.NoriDecompoundMode"
            } ]
          },
          "discard_punctuation" : {
            "type" : "boolean"
          },
          "user_dictionary" : {
            "type" : "string"
          },
          "user_dictionary_rules" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.FieldAndFormat" : {
      "description" : "A reference to a field with formatting instructions on how to return the value",
      "type" : "object",
      "properties" : {
        "field" : {
          "description" : "A wildcard pattern. The request returns values for field names matching this pattern.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "format" : {
          "description" : "The format in which the values are returned.",
          "type" : "string"
        },
        "include_unmapped" : {
          "type" : "boolean"
        }
      },
      "required" : [ "field" ]
    },
    "_types.analysis.EdgeNGramTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "edge_ngram" ]
          },
          "custom_token_chars" : {
            "type" : "string"
          },
          "max_gram" : {
            "type" : "number"
          },
          "min_gram" : {
            "type" : "number"
          },
          "token_chars" : {
            "default" : [ ],
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.analysis.TokenChar"
            }
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.IcuNormalizationMode" : {
      "type" : "string",
      "enum" : [ "decompose", "compose" ]
    },
    "_types.analysis.HindiNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "hindi_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.LatLonGeoLocation" : {
      "type" : "object",
      "properties" : {
        "lat" : {
          "description" : "Latitude",
          "type" : "number"
        },
        "lon" : {
          "description" : "Longitude",
          "type" : "number"
        }
      },
      "required" : [ "lat", "lon" ]
    },
    "_types.analysis.CjkBigramTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "cjk_bigram" ]
          },
          "ignored_scripts" : {
            "description" : "Array of character scripts for which to disable bigrams.",
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.analysis.CjkBigramIgnoredScript"
            }
          },
          "output_unigrams" : {
            "description" : "If `true`, emit tokens in both bigram and unigram form. If `false`, a CJK character is output in unigram form when it has no adjacent characters. Defaults to `false`.",
            "type" : "boolean"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_global.search._types.FieldCollapse" : {
      "type" : "object",
      "properties" : {
        "field" : {
          "description" : "The field to collapse the result set on",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        },
        "inner_hits" : {
          "description" : "The number of inner hits and their sort order",
          "oneOf" : [ {
            "$ref" : "#/definitions/_global.search._types.InnerHits"
          }, {
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_global.search._types.InnerHits"
            }
          } ]
        },
        "max_concurrent_group_searches" : {
          "description" : "The number of concurrent requests allowed to retrieve the inner_hits per group",
          "type" : "number"
        },
        "collapse" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.FieldCollapse"
          } ]
        }
      },
      "required" : [ "field" ]
    },
    "_types.analysis.ApostropheTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "apostrophe" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.SimplePatternTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "simple_pattern" ]
          },
          "pattern" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_global.search._types.Highlight" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_global.search._types.HighlightBase"
      }, {
        "type" : "object",
        "properties" : {
          "encoder" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_global.search._types.HighlighterEncoder"
            } ]
          },
          "fields" : {
            "type" : "object",
            "additionalProperties" : {
              "$ref" : "#/definitions/_global.search._types.HighlightField"
            }
          }
        },
        "required" : [ "fields" ]
      } ]
    },
    "_types.analysis.PersianNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "persian_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.FlattenGraphTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "flatten_graph" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.SoraniNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "sorani_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.WhitespaceTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "whitespace" ]
          },
          "max_token_length" : {
            "type" : "number"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.MappingCharFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.CharFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "mapping" ]
          },
          "mappings" : {
            "type" : "array",
            "items" : {
              "type" : "string"
            },
            "defaultSnippets" : [ {
              "body" : [ "${1::) => _happy_}" ]
            } ]
          },
          "mappings_path" : {
            "type" : "string"
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.query_dsl.RankFeatureFunction" : {
      "type" : "object"
    },
    "_types.analysis.StopWordLanguage" : {
      "type" : "string",
      "enum" : [ "_arabic_", "_armenian_", "_basque_", "_bengali_", "_brazilian_", "_bulgarian_", "_catalan_", "_cjk_", "_czech_", "_danish_", "_dutch_", "_english_", "_estonian_", "_finnish_", "_french_", "_galician_", "_german_", "_greek_", "_hindi_", "_hungarian_", "_indonesian_", "_irish_", "_italian_", "_latvian_", "_lithuanian_", "_norwegian_", "_persian_", "_portuguese_", "_romanian_", "_russian_", "_serbian_", "_sorani_", "_spanish_", "_swedish_", "_thai_", "_turkish_", "_none_" ]
    },
    "_types.analysis.PathHierarchyTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "path_hierarchy" ]
          },
          "buffer_size" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
            } ]
          },
          "delimiter" : {
            "type" : "string"
          },
          "replacement" : {
            "type" : "string"
          },
          "reverse" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          },
          "skip" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedinteger"
            } ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.ArabicNormalizationTokenFilter" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "arabic_normalization" ]
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.NGramTokenizer" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenizerBase"
      }, {
        "type" : "object",
        "properties" : {
          "type" : {
            "type" : "string",
            "enum" : [ "ngram" ]
          },
          "custom_token_chars" : {
            "type" : "string"
          },
          "max_gram" : {
            "type" : "number"
          },
          "min_gram" : {
            "type" : "number"
          },
          "token_chars" : {
            "default" : [ ],
            "type" : "array",
            "items" : {
              "$ref" : "#/definitions/_types.analysis.TokenChar"
            }
          }
        },
        "required" : [ "type" ]
      } ]
    },
    "_types.analysis.CompoundWordTokenFilterBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "max_subword_size" : {
            "description" : "Maximum subword character length. Longer subword tokens are excluded from the output. Defaults to `15`.",
            "type" : "number"
          },
          "min_subword_size" : {
            "description" : "Minimum subword character length. Shorter subword tokens are excluded from the output. Defaults to `2`.",
            "type" : "number"
          },
          "min_word_size" : {
            "description" : "Minimum word character length. Shorter word tokens are excluded from the output. Defaults to `5`.",
            "type" : "number"
          },
          "only_longest_match" : {
            "description" : "If `true`, only include the longest matching subword. Defaults to `false`.",
            "type" : "boolean"
          },
          "word_list" : {
            "description" : "A list of subwords to look for in the token stream. If found, the subword is included in the token output.\nEither this parameter or `word_list_path` must be specified.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "word_list_path" : {
            "description" : "Path to a file that contains a list of subwords to find in the token stream. If found, the subword is included in the token output.\nThis path must be absolute or relative to the config location, and the file must be UTF-8 encoded. Each token in the file must be separated by a line break.\nEither this parameter or `word_list` must be specified.",
            "type" : "string"
          }
        }
      } ]
    },
    "_types.query_dsl.FieldValueFactorModifier" : {
      "type" : "string",
      "enum" : [ "none", "log", "log1p", "log2p", "ln", "ln1p", "ln2p", "square", "sqrt", "reciprocal" ]
    },
    "_types.query_dsl.RangeRelation" : {
      "type" : "string",
      "enum" : [ "within", "contains", "intersects" ]
    },
    "_global.search._types.HighlighterEncoder" : {
      "type" : "string",
      "enum" : [ "default", "html" ]
    },
    "_types.analysis.TokenFilterBase" : {
      "type" : "object",
      "properties" : {
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        }
      }
    },
    "_types.analysis.PhoneticEncoder" : {
      "type" : "string",
      "enum" : [ "metaphone", "double_metaphone", "soundex", "refined_soundex", "caverphone1", "caverphone2", "cologne", "nysiis", "koelnerphonetik", "haasephonetik", "beider_morse", "daitch_mokotoff" ]
    },
    "_types.DateMath" : {
      "type" : "string"
    },
    "_types.SortCombinations" : {
      "oneOf" : [ {
        "$ref" : "#/definitions/_types.Field"
      }, {
        "$ref" : "#/definitions/_types.SortOptions"
      } ]
    },
    "_types.analysis.IcuTransformDirection" : {
      "type" : "string",
      "enum" : [ "forward", "reverse" ]
    },
    "_types.analysis.KeepTypesMode" : {
      "type" : "string",
      "enum" : [ "include", "exclude" ]
    },
    "_types.analysis.CharFilterBase" : {
      "type" : "object",
      "properties" : {
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        }
      }
    },
    "_types.query_dsl.UntypedDecayFunction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.DecayFunctionBase"
      }, {
        "type" : "object"
      } ]
    },
    "_types.analysis.EdgeNGramSide" : {
      "type" : "string",
      "enum" : [ "front", "back" ]
    },
    "_types.analysis.PhoneticNameType" : {
      "type" : "string",
      "enum" : [ "generic", "ashkenazi", "sephardic" ]
    },
    "_global.search._types.SourceFilter" : {
      "type" : "object",
      "properties" : {
        "exclude_vectors" : {
          "description" : "If `true`, vector fields are excluded from the returned source.\n\nThis option takes precedence over `includes`: any vector field will\nremain excluded even if it matches an `includes` rule.",
          "type" : "boolean"
        },
        "excludes" : {
          "description" : "A list of fields to exclude from the returned source.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Fields"
          } ]
        },
        "includes" : {
          "description" : "A list of fields to include in the returned source.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Fields"
          } ]
        }
      }
    },
    "_types.analysis.PhoneticLanguage" : {
      "type" : "string",
      "enum" : [ "any", "common", "cyrillic", "english", "french", "german", "hebrew", "hungarian", "polish", "romanian", "russian", "spanish" ]
    },
    "_types.analysis.PhoneticRuleType" : {
      "type" : "string",
      "enum" : [ "approx", "exact" ]
    },
    "_global.search._types.HighlightBase" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.HighlighterType"
          } ]
        },
        "boundary_chars" : {
          "description" : "A string that contains each boundary character.",
          "default" : ".,!? \\t\\n",
          "type" : "string"
        },
        "boundary_max_scan" : {
          "description" : "How far to scan for boundary characters.",
          "default" : 20.0,
          "type" : "number"
        },
        "boundary_scanner" : {
          "description" : "Specifies how to break the highlighted fragments: chars, sentence, or word.\nOnly valid for the unified and fvh highlighters.\nDefaults to `sentence` for the `unified` highlighter. Defaults to `chars` for the `fvh` highlighter.",
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.BoundaryScanner"
          } ]
        },
        "boundary_scanner_locale" : {
          "description" : "Controls which locale is used to search for sentence and word boundaries.\nThis parameter takes a form of a language tag, for example: `\"en-US\"`, `\"fr-FR\"`, `\"ja-JP\"`.",
          "default" : "Locale.ROOT",
          "type" : "string"
        },
        "force_source" : {
          "deprecated" : true,
          "type" : "boolean"
        },
        "fragmenter" : {
          "description" : "Specifies how text should be broken up in highlight snippets: `simple` or `span`.\nOnly valid for the `plain` highlighter.",
          "default" : "span",
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.HighlighterFragmenter"
          } ]
        },
        "fragment_size" : {
          "description" : "The size of the highlighted fragment in characters.",
          "default" : 100.0,
          "type" : "number"
        },
        "highlight_filter" : {
          "type" : "boolean"
        },
        "highlight_query" : {
          "description" : "Highlight matches for a query other than the search query.\nThis is especially useful if you use a rescore query because those are not taken into account by highlighting by default.",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
          } ]
        },
        "max_fragment_length" : {
          "type" : "number"
        },
        "max_analyzed_offset" : {
          "description" : "If set to a non-negative value, highlighting stops at this defined maximum limit.\nThe rest of the text is not processed, thus not highlighted and no error is returned\nThe `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when itâ€™s set to lower value than the query setting.",
          "type" : "number"
        },
        "no_match_size" : {
          "description" : "The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.",
          "default" : 0.0,
          "type" : "number"
        },
        "number_of_fragments" : {
          "description" : "The maximum number of fragments to return.\nIf the number of fragments is set to `0`, no fragments are returned.\nInstead, the entire field contents are highlighted and returned.\nThis can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.\nIf `number_of_fragments` is `0`, `fragment_size` is ignored.",
          "default" : 5.0,
          "type" : "number"
        },
        "options" : {
          "type" : "object",
          "additionalProperties" : {
            "type" : "object"
          }
        },
        "order" : {
          "description" : "Sorts highlighted fragments by score when set to `score`.\nBy default, fragments will be output in the order they appear in the field (order: `none`).\nSetting this option to `score` will output the most relevant fragments first.\nEach highlighter applies its own logic to compute relevancy scores.",
          "default" : "none",
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.HighlighterOrder"
          } ]
        },
        "phrase_limit" : {
          "description" : "Controls the number of matching phrases in a document that are considered.\nPrevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.\nWhen using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.\nOnly supported by the `fvh` highlighter.",
          "default" : 256.0,
          "type" : "number"
        },
        "post_tags" : {
          "description" : "Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.",
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        },
        "pre_tags" : {
          "description" : "Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.",
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        },
        "require_field_match" : {
          "description" : "By default, only fields that contains a query match are highlighted.\nSet to `false` to highlight all fields.",
          "default" : true,
          "type" : "boolean"
        },
        "tags_schema" : {
          "description" : "Set to `styled` to use the built-in tag schema.",
          "allOf" : [ {
            "$ref" : "#/definitions/_global.search._types.HighlighterTagsSchema"
          } ]
        }
      }
    },
    "_types.analysis.LowercaseTokenFilterLanguages" : {
      "type" : "string",
      "enum" : [ "greek", "irish", "turkish" ]
    },
    "_types.analysis.DelimitedPayloadEncoding" : {
      "type" : "string",
      "enum" : [ "int", "float", "identity" ]
    },
    "_types.analysis.TokenizerBase" : {
      "type" : "object",
      "properties" : {
        "version" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.VersionString"
          } ]
        }
      }
    },
    "_types.analysis.TokenChar" : {
      "type" : "string",
      "enum" : [ "letter", "digit", "whitespace", "punctuation", "symbol", "custom" ]
    },
    "_types.analysis.SynonymTokenFilterBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "expand" : {
            "description" : "Expands definitions for equivalent synonym rules. Defaults to `true`.",
            "type" : "boolean"
          },
          "format" : {
            "description" : "Sets the synonym rules format.",
            "allOf" : [ {
              "$ref" : "#/definitions/_types.analysis.SynonymFormat"
            } ]
          },
          "lenient" : {
            "description" : "If `true` ignores errors while parsing the synonym rules. It is important to note that only those synonym rules which cannot get parsed are ignored. Defaults to the value of the `updateable` setting.",
            "type" : "boolean"
          },
          "synonyms" : {
            "description" : "Used to define inline synonyms.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "synonyms_path" : {
            "description" : "Used to provide a synonym file. This path must be absolute or relative to the `config` location.",
            "type" : "string"
          },
          "synonyms_set" : {
            "description" : "Provide a synonym set created via Synonyms Management APIs.",
            "type" : "string"
          },
          "tokenizer" : {
            "deprecated" : true,
            "description" : "Controls the tokenizers that will be used to tokenize the synonym, this parameter is for backwards compatibility for indices that created before 6.0.",
            "type" : "string"
          },
          "updateable" : {
            "description" : "If `true` allows reloading search analyzers to pick up changes to synonym files. Only to be used for search analyzers. Defaults to `false`.",
            "type" : "boolean"
          }
        }
      } ]
    },
    "_types.query_dsl.NumericDecayFunction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.DecayFunctionBasedoubledouble"
      }, {
        "type" : "object"
      } ]
    },
    "_global.search._types.HighlightField" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_global.search._types.HighlightBase"
      }, {
        "type" : "object",
        "properties" : {
          "fragment_offset" : {
            "type" : "number"
          },
          "matched_fields" : {
            "allOf" : [ {
              "$ref" : "#/definitions/_types.Fields"
            } ]
          }
        }
      } ]
    },
    "_types.query_dsl.SimpleQueryStringFlag" : {
      "type" : "string",
      "enum" : [ "NONE", "AND", "NOT", "OR", "PREFIX", "PHRASE", "PRECEDENCE", "ESCAPE", "WHITESPACE", "FUZZY", "NEAR", "SLOP", "ALL" ]
    },
    "_types.query_dsl.GeoDecayFunction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.DecayFunctionBaseGeoLocationDistance"
      }, {
        "type" : "object"
      } ]
    },
    "_types.query_dsl.DateDecayFunction" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.query_dsl.DecayFunctionBaseDateMathDuration"
      }, {
        "type" : "object"
      } ]
    },
    "_types.analysis.CjkBigramIgnoredScript" : {
      "type" : "string",
      "enum" : [ "han", "hangul", "hiragana", "katakana" ]
    },
    "_types.analysis.WordDelimiterTokenFilterBase" : {
      "allOf" : [ {
        "$ref" : "#/definitions/_types.analysis.TokenFilterBase"
      }, {
        "type" : "object",
        "properties" : {
          "catenate_all" : {
            "description" : "If `true`, the filter produces catenated tokens for chains of alphanumeric characters separated by non-alphabetic delimiters. Defaults to `false`.",
            "type" : "boolean"
          },
          "catenate_numbers" : {
            "description" : "If `true`, the filter produces catenated tokens for chains of numeric characters separated by non-alphabetic delimiters. Defaults to `false`.",
            "type" : "boolean"
          },
          "catenate_words" : {
            "description" : "If `true`, the filter produces catenated tokens for chains of alphabetical characters separated by non-alphabetic delimiters. Defaults to `false`.",
            "type" : "boolean"
          },
          "generate_number_parts" : {
            "description" : "If `true`, the filter includes tokens consisting of only numeric characters in the output. If `false`, the filter excludes these tokens from the output. Defaults to `true`.",
            "type" : "boolean"
          },
          "generate_word_parts" : {
            "description" : "If `true`, the filter includes tokens consisting of only alphabetical characters in the output. If `false`, the filter excludes these tokens from the output. Defaults to `true`.",
            "type" : "boolean"
          },
          "preserve_original" : {
            "description" : "If `true`, the filter includes the original version of any split tokens in the output. This original version includes non-alphanumeric delimiters. Defaults to `false`.",
            "allOf" : [ {
              "$ref" : "#/definitions/_spec_utils.Stringifiedboolean"
            } ]
          },
          "protected_words" : {
            "description" : "Array of tokens the filter wonâ€™t split.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "protected_words_path" : {
            "description" : "Path to a file that contains a list of tokens the filter wonâ€™t split.\nThis path must be absolute or relative to the `config` location, and the file must be UTF-8 encoded. Each token in the file must be separated by a line break.",
            "type" : "string"
          },
          "split_on_case_change" : {
            "description" : "If `true`, the filter splits tokens at letter case transitions. For example: camelCase -> [ camel, Case ]. Defaults to `true`.",
            "type" : "boolean"
          },
          "split_on_numerics" : {
            "description" : "If `true`, the filter splits tokens at letter-number transitions. For example: j2se -> [ j, 2, se ]. Defaults to `true`.",
            "type" : "boolean"
          },
          "stem_english_possessive" : {
            "description" : "If `true`, the filter removes the English possessive (`'s`) from the end of each token. For example: O'Neil's -> [ O, Neil ]. Defaults to `true`.",
            "type" : "boolean"
          },
          "type_table" : {
            "description" : "Array of custom type mappings for characters. This allows you to map non-alphanumeric characters as numeric or alphanumeric to avoid splitting on those characters.",
            "type" : "array",
            "items" : {
              "type" : "string"
            }
          },
          "type_table_path" : {
            "description" : "Path to a file that contains custom type mappings for characters. This allows you to map non-alphanumeric characters as numeric or alphanumeric to avoid splitting on those characters.",
            "type" : "string"
          }
        }
      } ]
    },
    "_types.query_dsl.DecayFunctionBase" : {
      "type" : "object",
      "properties" : {
        "multi_value_mode" : {
          "description" : "Determines how the distance is calculated when a field used for computing the decay contains multiple values.",
          "default" : "min",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MultiValueMode"
          } ]
        }
      }
    },
    "_types.query_dsl.DecayFunctionBasedoubledouble" : {
      "type" : "object",
      "properties" : {
        "multi_value_mode" : {
          "description" : "Determines how the distance is calculated when a field used for computing the decay contains multiple values.",
          "default" : "min",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MultiValueMode"
          } ]
        }
      }
    },
    "_types.SortOptions" : {
      "type" : "object",
      "properties" : {
        "_score" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.ScoreSort"
          } ]
        },
        "_doc" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.ScoreSort"
          } ]
        },
        "_geo_distance" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.GeoDistanceSort"
          } ]
        },
        "_script" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.ScriptSort"
          } ]
        }
      },
      "minProperties" : 1,
      "maxProperties" : 1
    },
    "_types.query_dsl.DecayFunctionBaseGeoLocationDistance" : {
      "type" : "object",
      "properties" : {
        "multi_value_mode" : {
          "description" : "Determines how the distance is calculated when a field used for computing the decay contains multiple values.",
          "default" : "min",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MultiValueMode"
          } ]
        }
      }
    },
    "_types.query_dsl.DecayFunctionBaseDateMathDuration" : {
      "type" : "object",
      "properties" : {
        "multi_value_mode" : {
          "description" : "Determines how the distance is calculated when a field used for computing the decay contains multiple values.",
          "default" : "min",
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.MultiValueMode"
          } ]
        }
      }
    },
    "_types.analysis.SynonymFormat" : {
      "type" : "string",
      "enum" : [ "solr", "wordnet" ]
    },
    "_global.search._types.HighlighterFragmenter" : {
      "type" : "string",
      "enum" : [ "simple", "span" ]
    },
    "_global.search._types.HighlighterOrder" : {
      "type" : "string",
      "enum" : [ "score" ]
    },
    "_global.search._types.HighlighterType" : {
      "anyOf" : [ {
        "type" : "string",
        "enum" : [ "plain", "fvh", "unified" ]
      }, {
        "type" : "string"
      } ]
    },
    "_global.search._types.BoundaryScanner" : {
      "type" : "string",
      "enum" : [ "chars", "sentence", "word" ]
    },
    "_global.search._types.HighlighterTagsSchema" : {
      "type" : "string",
      "enum" : [ "styled" ]
    },
    "_types.ScriptSort" : {
      "type" : "object",
      "properties" : {
        "order" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.SortOrder"
          } ]
        },
        "script" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Script"
          } ]
        },
        "type" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.ScriptSortType"
          } ]
        },
        "mode" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.SortMode"
          } ]
        },
        "nested" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.NestedSortValue"
          } ]
        }
      },
      "required" : [ "script" ]
    },
    "_types.GeoDistanceSort" : {
      "type" : "object",
      "properties" : {
        "mode" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.SortMode"
          } ]
        },
        "distance_type" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.GeoDistanceType"
          } ]
        },
        "ignore_unmapped" : {
          "type" : "boolean"
        },
        "order" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.SortOrder"
          } ]
        },
        "unit" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.DistanceUnit"
          } ]
        },
        "nested" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.NestedSortValue"
          } ]
        }
      }
    },
    "_types.ScoreSort" : {
      "type" : "object",
      "properties" : {
        "order" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.SortOrder"
          } ]
        }
      }
    },
    "_types.query_dsl.MultiValueMode" : {
      "type" : "string",
      "enum" : [ "min", "max", "avg", "sum" ]
    },
    "_types.ScriptSortType" : {
      "type" : "string",
      "enum" : [ "string", "number", "version" ]
    },
    "_types.SortOrder" : {
      "type" : "string",
      "enum" : [ "asc", "desc" ]
    },
    "_types.DistanceUnit" : {
      "type" : "string",
      "enum" : [ "in", "ft", "yd", "mi", "nmi", "km", "m", "cm", "mm" ]
    },
    "_types.NestedSortValue" : {
      "type" : "object",
      "properties" : {
        "filter" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.query_dsl.QueryContainer"
          } ]
        },
        "max_children" : {
          "type" : "number"
        },
        "nested" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.NestedSortValue"
          } ]
        },
        "path" : {
          "allOf" : [ {
            "$ref" : "#/definitions/_types.Field"
          } ]
        }
      },
      "required" : [ "path" ]
    },
    "_types.SortMode" : {
      "type" : "string",
      "enum" : [ "min", "max", "sum", "avg", "median" ]
    },
    "legacy_index_template" : {
      "type" : "object",
      "properties" : {
        "aliases" : {
          "description" : "Specific to legacy index templates.\nIndex aliases to add.",
          "type" : "object",
          "additionalProperties" : {
            "$ref" : "#/definitions/indices._types:Alias"
          }
        },
        "mappings" : {
          "description" : "Specific to legacy index templates.",
          "$ref" : "#/definitions/_types.mapping:TypeMapping"
        },
        "settings" : {
          "description" : "Specific to legacy index templates.",
          "$ref" : "#/definitions/indices._types:IndexSettings"
        },
        "order" : {
          "description" : "Specific to legacy index templates.",
          "type" : "integer",
          "default" : 0
        }
      }
    },
    "component_template" : {
      "type" : "object",
      "required" : [ "template" ],
      "properties" : {
        "template" : {
          "$ref" : "#/definitions/indices.put_index_template:IndexTemplateMapping"
        },
        "version" : {
          "$ref" : "#/definitions/_types:VersionNumber"
        },
        "_meta" : {
          "$ref" : "#/definitions/_types:Metadata"
        },
        "allow_auto_create" : {
          "description" : "This setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that template even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false`, then indices or data streams matching the template must always be explicitly created, and may never be automatically created.",
          "type" : "boolean"
        },
        "deprecated" : {
          "description" : "Marks this component template as deprecated. \nWhen a deprecated component template is referenced by a non-deprecated index template, Elasticsearch will emit a deprecation warning.",
          "type" : "boolean"
        }
      }
    },
    "analyzer_examples" : {
      "examples" : [ "custom", "fingerprint", "keyword", "nori", "pattern", "simple", "standard", "stop", "whitespace", "icu_analyzer", "kuromoji", "snowball", "arabic", "armenian", "basque", "bengali", "brazilian", "bulgarian", "catalan", "chinese", "cjk", "czech", "danish", "dutch", "english", "estonian", "finnish", "french", "galician", "german", "greek", "hindi", "hungarian", "indonesian", "irish", "italian", "latvian", "lithuanian", "norwegian", "persian", "portuguese", "romanian", "russian", "serbian", "sorani", "spanish", "swedish", "turkish", "thai" ]
    },
    "tokenizer_examples" : {
      "examples" : [ "standard", "char_group", "classic", "edge_ngram", "keyword", "letter", "lowercase", "ngram", "path_hierarchy", "pattern", "simple_pattern", "simple_pattern_split", "thai", "uax_url_email", "whitespace" ]
    },
    "filter_examples" : {
      "examples" : [ "arabic_normalization", "asciifolding", "bengali_normalization", "cjk_width", "decimal_digit", "elision", "german_normalization", "hindi_normalization", "indic_normalization", "lowercase", "persian_normalization", "scandinavian_folding", "serbian_normalization", "sorani_normalization", "uppercase" ]
    }
  },
  "allOf" : [ {
    "$ref" : "#/definitions/composable_index_template"
  }, {
    "$ref" : "#/definitions/legacy_index_template"
  } ]
}